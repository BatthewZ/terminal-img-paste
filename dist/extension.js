"use strict";var _e=Object.create;var W=Object.defineProperty;var je=Object.getOwnPropertyDescriptor;var qe=Object.getOwnPropertyNames;var Ge=Object.getPrototypeOf,Ue=Object.prototype.hasOwnProperty;var ze=(e,t)=>{for(var r in t)W(e,r,{get:t[r],enumerable:!0})},ie=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of qe(t))!Ue.call(e,n)&&n!==r&&W(e,n,{get:()=>t[n],enumerable:!(o=je(t,n))||o.enumerable});return e};var f=(e,t,r)=>(r=e!=null?_e(Ge(e)):{},ie(t||!e||!e.__esModule?W(r,"default",{value:e,enumerable:!0}):r,e)),He=e=>ie(W({},"__esModule",{value:!0}),e);var Ft={};ze(Ft,{activate:()=>Et,deactivate:()=>Tt});module.exports=He(Ft);var x=f(require("vscode"));var T=f(require("fs")),le=require("child_process"),L=null;function Ye(){switch(process.platform){case"darwin":return"macos";case"win32":return"windows";default:return"linux"}}function Je(){try{return T.readFileSync("/proc/version","utf-8")}catch{return null}}function ce(e){return e?/microsoft/i.test(e):!1}function Xe(e){return!e||!ce(e)?null:/microsoft-standard-WSL2/i.test(e)?2:1}function Ve(){return T.existsSync("/mnt/wslg/")}function Qe(e,t){if(e!=="linux")return"unknown";if(t)return process.env.WAYLAND_DISPLAY?"wayland":process.env.DISPLAY?"x11":"unknown";let r=process.env.XDG_SESSION_TYPE;return r==="wayland"?"wayland":r==="x11"?"x11":process.env.WAYLAND_DISPLAY?"wayland":"unknown"}function se(e){try{return(0,le.execFileSync)("command",["-v",e],{encoding:"utf-8",timeout:5e3,shell:!0}).trim()||null}catch{return null}}function Ke(e,t){if(e==="windows")return"powershell.exe";if(t){let r=["/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe","/mnt/c/Program Files/PowerShell/7/pwsh.exe"];for(let n of r)if(T.existsSync(n))return n;let o=se("powershell.exe")??se("pwsh.exe");return o||"powershell.exe"}return null}function me(){if(L)return L;let e=Ye(),t=e==="linux"?Je():null,r=e==="linux"?ce(t):!1,o=r?Xe(t):null,n=r?Ve():!1,a=Qe(e,r),s=Ke(e,r);return L={os:e,isWSL:r,wslVersion:o,hasWslg:n,displayServer:a,powershellPath:s},L}var de=f(require("vscode"));function fe(){let e=de.env.remoteName;return e?{remote:!0,type:e}:{remote:!1}}var F=require("child_process"),V=1e4,Ze=10*1024*1024,pe=50*1024*1024;function Q(e){return"code"in e&&typeof e.code=="number"?e.code:e.code??"unknown"}function d(e,t,r){return new Promise((o,n)=>{(0,F.execFile)(e,t,{encoding:"utf-8",timeout:r?.timeout??V,maxBuffer:r?.maxBuffer??Ze,cwd:r?.cwd},(a,s,i)=>{if(a){n(new Error(`Command "${e}" failed (exit code ${Q(a)}): ${i||a.message}`));return}o({stdout:s,stderr:i})})})}function w(e,t,r){return r?.input?et(e,t,r):new Promise((o,n)=>{(0,F.execFile)(e,t,{encoding:"buffer",timeout:r?.timeout??V,maxBuffer:r?.maxBuffer??pe,cwd:r?.cwd},(a,s,i)=>{let l=i instanceof Buffer?i.toString("utf-8"):String(i);if(a){n(new Error(`Command "${e}" failed (exit code ${Q(a)}): ${l||a.message}`));return}o({stdout:s,stderr:l})})})}function et(e,t,r){let o=r.timeout??V,n=r.maxBuffer??pe;return new Promise((a,s)=>{let i=(0,F.spawn)(e,t,{stdio:["pipe","pipe","pipe"],cwd:r.cwd}),l=[],m=[],E=0,J=0,h=!1,S=setTimeout(()=>{h||(h=!0,i.kill("SIGTERM"),s(new Error(`Command "${e}" failed (exit code ETIMEDOUT): timed out after ${o}ms`)))},o);i.stdout.on("data",u=>{if(E+=u.length,E>n){h||(h=!0,clearTimeout(S),i.kill("SIGTERM"),s(new Error(`Command "${e}" failed (exit code ERR_CHILD_PROCESS_STDIO_MAXBUFFER): stdout maxBuffer length exceeded`)));return}l.push(u)}),i.stderr.on("data",u=>{J+=u.length,J<=n&&m.push(u)}),i.on("error",u=>{h||(h=!0,clearTimeout(S),s(new Error(`Command "${e}" failed (exit code ${Q(u)}): ${u.message}`)))}),i.on("close",u=>{if(h)return;h=!0,clearTimeout(S);let M=Buffer.concat(m).toString("utf-8");if(u!==0){s(new Error(`Command "${e}" failed (exit code ${u??"unknown"}): ${M||`process exited with code ${u}`}`));return}a({stdout:Buffer.concat(l),stderr:M})}),i.stdin.on("error",()=>{}),i.stdin.end(r.input)})}var he=require("child_process");var ue=f(require("vscode"));function K(){let e=new Date,t=String(e.getHours()).padStart(2,"0"),r=String(e.getMinutes()).padStart(2,"0"),o=String(e.getSeconds()).padStart(2,"0"),n=String(e.getMilliseconds()).padStart(3,"0");return`[${t}:${r}:${o}.${n}]`}function tt(e){let t=ue.window.createOutputChannel(e);return{info(r){t.appendLine(`${K()} [INFO] ${r}`)},warn(r,o){let n=`${K()} [WARN] ${r}`;o!==void 0&&(o instanceof Error&&o.stack?n+=`
${o.stack}`:n+=`
${String(o)}`),t.appendLine(n)},error(r,o){let n=`${K()} [ERROR] ${r}`;o!==void 0&&(o instanceof Error&&o.stack?n+=`
${o.stack}`:n+=`
${String(o)}`),t.appendLine(n)},show(){t.show()}}}var c=tt("Terminal Image Paste");var ge=new Map,rt=process.platform==="win32";async function ot(e){let t=ge.get(e);if(t!==void 0)return t;let r=rt?"where":"which";try{let o=await new Promise((n,a)=>{(0,he.execFile)(r,[e],{timeout:5e3},(s,i)=>{if(s){a(s);return}let l=i.trim().split(/\r?\n/)[0];n(l)})});return ge.set(e,o),o}catch{c.warn(`Could not resolve absolute path for "${e}" \u2014 using bare name`);return}}async function I(e){return await ot(e)??e}async function $(){let{stdout:e}=await d("osascript",["-e","clipboard info"]);return e}function k(e){let t=[];return e.includes("\xABclass PNGf\xBB")&&t.push("png"),(e.includes("\xABclass JPEG\xBB")||e.includes("\xABclass JPEf\xBB"))&&t.push("jpeg"),e.includes("\xABclass TIFF\xBB")&&t.push("tiff"),(e.includes("\xABclass BMP \xBB")||e.includes("\xABclass BMPf\xBB"))&&t.push("bmp"),t}var O=class{resolvedPngpastePath;async getPngpastePath(){return this.resolvedPngpastePath===void 0&&(this.resolvedPngpastePath=await I("pngpaste")),this.resolvedPngpastePath}requiredTool(){return"pngpaste"}async isToolAvailable(){try{return await d("which",["pngpaste"]),!0}catch{return!1}}async hasImage(){try{let t=await $();return k(t).length>0}catch{return!1}}async detectFormat(){let t=await $(),r=k(t);if(r.length>0)return r[0];throw new Error("No image found in clipboard")}async readImage(){if(!await this.hasImage())throw new Error("No image found in clipboard");let r=await this.getPngpastePath(),{stdout:o}=await w(r,["-"]);return{data:o,format:"png"}}};var we={png:"PNGf",jpeg:"JPEG",tiff:"TIFF"},_=class{requiredTool(){return"osascript (built-in)"}async isToolAvailable(){return process.platform==="darwin"}async hasImage(){try{let t=await $();return k(t).length>0}catch{return!1}}async detectFormat(){let t=await $(),r=k(t);if(r.length>0)return r[0];throw new Error("No image found in clipboard")}async readImage(){let t=await this.detectFormat(),r=t in we,o=r?we[t]:"PNGf",n=r?t:"png",{stdout:a}=await w("osascript",["-e",`set imgData to (the clipboard as \xABclass ${o}\xBB)`,"-e","return imgData"]);return{data:a,format:n}}};var ve=[["image/png","png"],["image/jpeg","jpeg"],["image/webp","webp"],["image/tiff","tiff"],["image/bmp","bmp"],["image/x-bmp","bmp"]];function nt(e){for(let[t,r]of ve)if(e.includes(t))return r;return/^image\//m.test(e)?"unknown":null}function at(e){for(let[t,r]of ve)if(e.includes(t))return{mime:t,format:r};return/^image\//m.test(e)?{mime:"image/png",format:"unknown"}:null}var b=class{displayServer;resolvedToolPath;constructor(t){this.displayServer=t}isWayland(){return this.displayServer==="wayland"}toolName(){return this.isWayland()?"wl-paste":"xclip"}async getToolPath(){return this.resolvedToolPath===void 0&&(this.resolvedToolPath=await I(this.toolName())),this.resolvedToolPath}requiredTool(){return this.isWayland()?"wl-clipboard (wl-paste)":"xclip"}async isToolAvailable(){try{return this.isWayland()?await d("which",["wl-paste"]):await d("which",["xclip"]),!0}catch{return!1}}async getClipboardTypes(){let t=await this.getToolPath();if(this.isWayland()){let{stdout:r}=await d(t,["--list-types"]);return r}else{let{stdout:r}=await d(t,["-selection","clipboard","-t","TARGETS","-o"]);return r}}async hasImage(){try{let t=await this.getClipboardTypes();return/^image\//m.test(t)}catch{return!1}}async detectFormat(){let t=await this.getClipboardTypes(),r=nt(t);if(r!==null)return r;throw new Error("No image found in clipboard")}async readImage(){let t=await this.getClipboardTypes(),r=at(t);if(!r)throw new Error("No image found in clipboard");let{mime:o,format:n}=r,a=n==="unknown"?"png":n,s=await this.getToolPath(),{stdout:i}=this.isWayland()?await w(s,["--type",o]):await w(s,["-selection","clipboard","-t",o,"-o"]);return{data:i,format:a}}};var Z=f(require("fs"));function R(e){return Buffer.from(e,"utf16le").toString("base64")}var it="Add-Type -AssemblyName System.Windows.Forms; if ([System.Windows.Forms.Clipboard]::ContainsImage()) { echo 'yes' } else { echo 'no' }",st="Add-Type -AssemblyName System.Windows.Forms; $img = [System.Windows.Forms.Clipboard]::GetImage(); if ($img -eq $null) { exit 1 }; $tmp = [System.IO.Path]::GetTempFileName(); $img.Save($tmp, [System.Drawing.Imaging.ImageFormat]::Png); Write-Output $tmp",C=class{async isToolAvailable(){try{return await d(this.powershellExe,["-Command","echo ok"]),!0}catch{return!1}}async hasImage(){try{return(await d(this.powershellExe,["-EncodedCommand",R(it)])).stdout.trim()==="yes"}catch{return!1}}async detectFormat(){if(!await this.hasImage())throw new Error("No image found in clipboard");return"png"}async readImage(){if(!await this.hasImage())throw new Error("No image found in clipboard");let r;try{r=(await d(this.powershellExe,["-EncodedCommand",R(st)])).stdout.trim()}catch(n){throw new Error(`PowerShell execution failed: ${n instanceof Error?n.message:n}`)}let o=await this.resolveTempPath(r);try{return{data:await Z.promises.readFile(o),format:"png"}}catch(n){throw new Error(`Temp file read failed: could not read "${o}": ${n instanceof Error?n.message:n}`)}finally{Z.promises.unlink(o).catch(n=>{c.warn(`Failed to clean up temp file: ${o}`,n)})}}};var j=class extends C{resolvedPsPath;get powershellExe(){return this.resolvedPsPath??"powershell.exe"}async resolvePs(){this.resolvedPsPath===void 0&&(this.resolvedPsPath=await I("powershell.exe"))}requiredTool(){return"PowerShell (built-in)"}async isToolAvailable(){return await this.resolvePs(),super.isToolAvailable()}async resolveTempPath(t){return t}};var A=class extends C{psPath;constructor(t){super(),this.psPath=t.powershellPath??"powershell.exe"}get powershellExe(){return this.psPath}requiredTool(){return"PowerShell (via WSL interop)"}async resolveTempPath(t){try{return(await d("wslpath",["-u",t])).stdout.trim()}catch(r){throw new Error(`wslpath conversion failed: could not convert "${t}" to a WSL path: ${r instanceof Error?r.message:r}`)}}};var y=class{readers;constructor(t){if(t.length===0)throw new Error("FallbackClipboardReader requires at least one reader");this.readers=t}requiredTool(){return this.readers.map(t=>t.requiredTool()).join(" or ")}async isToolAvailable(){for(let t of this.readers)if(await t.isToolAvailable())return!0;return!1}async hasImage(){for(let t of this.readers)try{if(await t.hasImage())return!0}catch{continue}return!1}async detectFormat(){let t=[];for(let r of this.readers)try{return await r.detectFormat()}catch(o){t.push(o instanceof Error?o:new Error(String(o)))}throw new AggregateError(t,`All clipboard readers failed to detect format: ${t.map(r=>r.message).join("; ")}`)}async readImage(){let t=[];for(let r of this.readers)try{if(!await r.isToolAvailable()){t.push(new Error(`${r.requiredTool()}: tool not available`));continue}return await r.readImage()}catch(o){t.push(o instanceof Error?o:new Error(String(o)))}throw new AggregateError(t,`All clipboard readers failed: ${t.map(r=>r.message).join("; ")}`)}};function be(e){if(e.isWSL){let t=e.displayServer==="x11"||e.displayServer==="wayland";if(e.hasWslg&&t)return new y([new b(e.displayServer),new A(e)]);let r=[new A(e)];return t&&r.push(new b(e.displayServer)),r.length===1?r[0]:new y(r)}switch(e.os){case"macos":return new y([new O,new _]);case"windows":return new j;case"linux":{let t=new b(e.displayServer),r=e.displayServer==="wayland"?"x11":"wayland",o=new b(r);return new y([t,o])}}}var Ie=f(require("crypto")),p=f(require("fs")),g=f(require("path")),N=f(require("vscode"));var ye=f(require("fs"));async function q(e,t){await ye.promises.writeFile(e,t,{mode:384})}var lt=".tip-images",Ce=[".png",".jpg",".jpeg",".tiff",".bmp",".webp"];function ct(e){switch(e){case"jpeg":return".jpg";case"tiff":return".tiff";case"bmp":return".bmp";case"webp":return".webp";case"png":case"unknown":default:return".png"}}var ee=Buffer.from([137,80,78,71,13,10,26,10]);function mt(e,t){switch(t){case"png":if(e.length<ee.length||!e.subarray(0,ee.length).equals(ee))throw new Error("Clipboard data is not a valid PNG image");break;case"jpeg":if(e.length<2||e[0]!==255||e[1]!==216)throw new Error("Clipboard data is not a valid JPEG image");break;case"bmp":if(e.length<2||e[0]!==66||e[1]!==77)throw new Error("Clipboard data is not a valid BMP image");break;case"webp":if(e.length<12||e.subarray(0,4).toString("ascii")!=="RIFF"||e.subarray(8,12).toString("ascii")!=="WEBP")throw new Error("Clipboard data is not a valid WebP image");break;case"tiff":if(e.length<2||!(e[0]===73&&e[1]===73||e[0]===77&&e[1]===77))throw new Error("Clipboard data is not a valid TIFF image");break;case"unknown":c.warn("Skipping image validation for unknown format");break}}function B(){return N.workspace.getConfiguration("terminalImgPaste")}function re(){let e=N.workspace.workspaceFolders;if(!e||e.length===0)throw N.window.showErrorMessage("Terminal Image Paste: No workspace folder is open. Please open a folder first."),new Error("No workspace folder is open");return e[0].uri.fsPath}function Ee(){return B().get("folderName",lt)}function Pe(){let e=re(),t=Ee(),r=g.resolve(e,t);if(!r.startsWith(e+g.sep))throw new Error(`Configured folderName "${t}" must resolve to a subdirectory of the workspace root`);return r}var Te="img-{timestamp}",xe=["{timestamp}","{n}","{hash}"];function dt(e,t,r){e||(e=Te);let o=new Date;if(e.includes("{"))xe.some(s=>e.includes(s))||c.warn(`Filename pattern "${e}" lacks a uniqueness placeholder (${xe.join(", ")}). Filenames may collide.`);else{let s=Se(o);e=`${e}-${s}`}let a=e;if(a=a.replace(/\{timestamp\}/g,Se(o)),a=a.replace(/\{date\}/g,G(o)),a=a.replace(/\{time\}/g,Fe(o)),a.includes("{hash}")){let s=Ie.createHash("sha256").update(t).digest("hex").slice(0,8);a=a.replace(/\{hash\}/g,s)}return a.includes("{n}")&&(a=ft(a,r)),a}function Se(e){let t=String(e.getMilliseconds()).padStart(3,"0");return`${G(e)}T${Fe(e)}-${t}`}function G(e){let t=e.getFullYear(),r=String(e.getMonth()+1).padStart(2,"0"),o=String(e.getDate()).padStart(2,"0");return`${t}-${r}-${o}`}function Fe(e){let t=String(e.getHours()).padStart(2,"0"),r=String(e.getMinutes()).padStart(2,"0"),o=String(e.getSeconds()).padStart(2,"0");return`${t}-${r}-${o}`}function ft(e,t){let r=e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/\\{n\\}/g,"(\\d+)"),o=new RegExp(`^${r}`),n=0;for(let a of t){let i=a.replace(/\.[^.]+$/,"").match(o);if(i&&i[1]){let l=parseInt(i[1],10);l>n&&(n=l)}}return e.replace(/\{n\}/g,String(n+1))}function pt(e,t,r){let o=B().get("filenamePattern",Te),n=dt(o,t,r),a=ct(e);return`${n}${a}`}async function te(e,t){let r=await p.promises.realpath(e),o=await p.promises.realpath(t),n=process.platform==="win32"||process.platform==="darwin",a=n?r.toLowerCase():r,s=n?o.toLowerCase():o;if(a!==s&&!a.startsWith(s+g.sep))throw new Error(`Image folder resolves to a path outside the workspace (possible symlink escape): ${r}`);return r}function ut(e,t=new Date){switch(e){case"daily":return G(t);case"monthly":return G(t).substring(0,7);case"flat":default:return""}}async function $e(e){let t=[],r;try{r=await p.promises.readdir(e,{withFileTypes:!0})}catch{return t}for(let o of r){let n=g.join(e,o.name);o.isDirectory()?t.push(...await $e(n)):Ce.some(a=>o.name.endsWith(a))&&t.push({filePath:n,name:o.name})}return t}async function gt(e,t){if(e!==t)try{(await p.promises.readdir(e)).length===0&&(await p.promises.rmdir(e),c.info(`Removed empty directory: ${e}`))}catch{}}function ke(){return{async save(e,t="png"){mt(e,t);let r=Pe(),o=re();await p.promises.mkdir(r,{recursive:!0}),await te(r,o);let n=B().get("organizeFolders","flat"),a=ut(n),s=a?g.join(r,a):r;a&&(await p.promises.mkdir(s,{recursive:!0}),await te(s,o));let i;try{i=await p.promises.readdir(s)}catch{i=[]}let l=pt(t,e,i),m=g.join(s,l);return await q(m,e),await te(m,o),c.info(`Saved image: ${m}`),await this.cleanup(),await this.ensureGitIgnored(),m},async cleanup(){let e=B(),t=e.get("maxImages",20),r=Number.isInteger(t)&&t>0?t:20,o=e.get("organizeFolders","flat"),n=Pe();if(o==="flat"){let a;try{a=await p.promises.readdir(n)}catch{return}let s=a.filter(l=>Ce.some(m=>l.endsWith(m))).sort();if(s.length<=r)return;let i=s.slice(0,s.length-r);for(let l of i){let m=g.join(n,l);try{await p.promises.unlink(m),c.info(`Deleted old image: ${m}`)}catch(E){c.warn(`Failed to delete old image: ${m}`,E)}}}else{let a=await $e(n);if(a.sort((l,m)=>l.name.localeCompare(m.name)),a.length<=r)return;let s=a.slice(0,a.length-r),i=new Set;for(let l of s)try{await p.promises.unlink(l.filePath),c.info(`Deleted old image: ${l.filePath}`),i.add(g.dirname(l.filePath))}catch(m){c.warn(`Failed to delete old image: ${l.filePath}`,m)}for(let l of i)await gt(l,n)}},async ensureGitIgnored(){if(!B().get("autoGitIgnore",!0))return;let t=Ee(),r=re(),o=g.join(r,".gitignore"),n;try{n=await p.promises.readFile(o,"utf-8")}catch{await p.promises.writeFile(o,t+`
`,"utf-8"),c.info(`Created .gitignore with ${t}`);return}if(n.split(`
`).map(i=>i.trim()).includes(t))return;let s=n.endsWith(`
`)?"":`
`;await p.promises.writeFile(o,n+s+t+`
`,"utf-8"),c.info(`Added ${t} to .gitignore`)}}}var D=f(require("vscode"));var Ae=f(require("path")),ht=[{pattern:/\bbash\b/i,type:"bash"},{pattern:/\bzsh\b/i,type:"zsh"},{pattern:/\bfish\b/i,type:"fish"},{pattern:/\b(?:pwsh|powershell)\b/i,type:"powershell"},{pattern:/\bcmd\b/i,type:"cmd"}];function Re(e){let t=Ae.basename(e).replace(/\.exe$/i,"");for(let{pattern:r,type:o}of ht)if(r.test(t))return o;return"unknown"}function Be(e){let t=e.creationOptions?.shellPath;if(t)return Re(t);let r=process.env.SHELL;return r?Re(r):process.platform==="win32"?"powershell":"unknown"}function wt(e,t){switch(t){case"fish":return"'"+e.replace(/\\/g,"\\\\").replace(/'/g,"\\'")+"'";case"powershell":return'"'+e.replace(/`/g,"``").replace(/\$/g,"`$").replace(/"/g,'`"')+'"';case"cmd":return'"'+e.replace(/%/g,"%%").replace(/"/g,'""')+'"';case"bash":case"zsh":case"unknown":default:return"'"+e.replace(/'/g,"'\\''")+"'"}}function oe(e){let t=D.window.activeTerminal;if(!t){D.window.showErrorMessage("Terminal Image Paste: No active terminal. Please open a terminal first.");return}let r=Be(t),o=wt(e,r),a=D.workspace.getConfiguration("terminalImgPaste").get("sendNewline",!1);t.sendText(o,a),c.info(`Inserted path into terminal (${r}): ${o}`)}var U=f(require("fs")),Ne=f(require("os")),ne=f(require("path"));async function De(e,t,r,o){if(r==="auto"||t===r)return{data:e,format:t};try{return{data:await bt(e,t,r,o),format:r}}catch(n){return c.warn(`Image conversion from ${t} to ${r} failed, saving in native format: ${n instanceof Error?n.message:String(n)}`),{data:e,format:t}}}async function vt(e){if(e.os==="macos")return"sips";if(e.os==="windows"||e.isWSL)return e.powershellPath?"powershell":null;try{return await d("which",["convert"]),"magick"}catch{}try{return await d("which",["ffmpeg"]),"ffmpeg"}catch{}return null}async function bt(e,t,r,o){let n=await vt(o);if(n===null)throw new Error("No conversion tool available");switch(n){case"sips":return yt(e,r);case"magick":return Pt(e,t,r);case"ffmpeg":return xt(e,r);case"powershell":return St(e,r,o.powershellPath)}}async function yt(e,t){let r=Ne.tmpdir(),o=ne.join(r,`tip-convert-in-${Date.now()}`),n=t==="jpeg"?"jpg":"png",a=ne.join(r,`tip-convert-out-${Date.now()}.${n}`);await q(o,e);try{return await d("sips",["--setProperty","format",t==="jpeg"?"jpeg":"png",o,"--out",a]),await U.promises.readFile(a)}finally{await U.promises.unlink(o).catch(()=>{}),await U.promises.unlink(a).catch(()=>{})}}async function Pt(e,t,r){let o=`${t}:-`,n=`${r}:-`;return(await w("convert",[o,n],{input:e})).stdout}async function xt(e,t){return(await w("ffmpeg",["-hide_banner","-loglevel","error","-f","image2pipe","-i","-","-f","image2","-c:v",t==="png"?"png":"mjpeg","-"],{input:e})).stdout}async function St(e,t,r){return(await w(r,["-NoProfile","-EncodedCommand",R(`
Add-Type -AssemblyName System.Drawing
$stdin = [Console]::OpenStandardInput()
$ms = New-Object System.IO.MemoryStream
$stdin.CopyTo($ms)
$ms.Position = 0
$img = [System.Drawing.Image]::FromStream($ms)
$outMs = New-Object System.IO.MemoryStream
$img.Save($outMs, [System.Drawing.Imaging.ImageFormat]::${t==="png"?"Png":"Jpeg"})
[Console]::OpenStandardOutput().Write($outMs.ToArray(), 0, $outMs.Length)
$img.Dispose()
$ms.Dispose()
$outMs.Dispose()
`)],{input:e})).stdout}var z=f(require("vscode")),Me=1e4;function We(e,t){return new Promise(r=>{let o=!1,n=m=>{o||(o=!0,clearTimeout(l),a.dispose(),r(m))},a=z.window.createWebviewPanel("terminalImgPaste.preview","Image Preview \u2014 Terminal Image Paste",z.ViewColumn.Active,{enableScripts:!0}),s=`image/${t}`,i=e.toString("base64");a.webview.html=It(s,i,Me),a.webview.onDidReceiveMessage(m=>{m.command==="paste"?n(!0):(m.command==="cancel"||m.command==="timeout")&&n(!1)}),a.onDidDispose(()=>{n(!1)});let l=setTimeout(()=>{n(!1)},Me+500)})}function It(e,t,r){let o=Math.round(r/1e3);return`<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; img-src data:; style-src 'unsafe-inline'; script-src 'unsafe-inline';">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Preview</title>
  <style>
    body { font-family: var(--vscode-font-family, sans-serif); padding: 16px; text-align: center; color: var(--vscode-foreground); background: var(--vscode-editor-background); }
    img { max-width: 100%; max-height: 60vh; border: 1px solid var(--vscode-panel-border, #444); margin-bottom: 12px; }
    .info { margin-bottom: 16px; opacity: 0.8; font-size: 13px; }
    .buttons { display: flex; justify-content: center; gap: 12px; }
    button { padding: 8px 20px; font-size: 14px; cursor: pointer; border: none; border-radius: 4px; }
    .btn-paste { background: var(--vscode-button-background, #0078d4); color: var(--vscode-button-foreground, #fff); }
    .btn-paste:hover { background: var(--vscode-button-hoverBackground, #005a9e); }
    .btn-cancel { background: var(--vscode-button-secondaryBackground, #333); color: var(--vscode-button-secondaryForeground, #fff); }
    .btn-cancel:hover { background: var(--vscode-button-secondaryHoverBackground, #444); }
    .countdown { margin-top: 12px; font-size: 12px; opacity: 0.6; }
  </style>
</head>
<body>
  <img id="preview" src="data:${e};base64,${t}" alt="Clipboard image preview"
       onload="document.getElementById('dims').textContent = this.naturalWidth + ' \xD7 ' + this.naturalHeight + ' px';" />
  <div class="info" id="dims"></div>
  <div class="buttons">
    <button class="btn-paste" id="pasteBtn">Paste</button>
    <button class="btn-cancel" id="cancelBtn">Cancel</button>
  </div>
  <div class="countdown" id="timer">Auto-cancel in ${o}s</div>
  <script>
    const vscode = acquireVsCodeApi();
    document.getElementById('pasteBtn').addEventListener('click', () => vscode.postMessage({ command: 'paste' }));
    document.getElementById('cancelBtn').addEventListener('click', () => vscode.postMessage({ command: 'cancel' }));

    let remaining = ${o};
    const timerEl = document.getElementById('timer');
    const interval = setInterval(() => {
      remaining--;
      if (remaining <= 0) {
        clearInterval(interval);
        timerEl.textContent = 'Auto-cancelled';
        vscode.postMessage({ command: 'timeout' });
      } else {
        timerEl.textContent = 'Auto-cancel in ' + remaining + 's';
      }
    }, 1000);
  </script>
</body>
</html>`}var P=f(require("vscode"));function H(){return P.workspace.getConfiguration("terminalImgPaste").get("notifications","all")}function Ct(){return{statusBar(e,t=3e3){c.info(e),H()==="all"&&P.window.setStatusBarMessage(e,t)},info(e){c.info(e),H()==="all"&&P.window.showInformationMessage(e)},async warning(e,...t){return c.warn(e),H()==="all"?P.window.showWarningMessage(e,...t):t.length>0?t[0]:void 0},error(e){c.error(e);let t=H();(t==="all"||t==="errors")&&P.window.showErrorMessage(e)}}}var v=Ct();var Y=class{_queue=[];_locked=!1;acquire(){return new Promise(t=>{let r=()=>{this._locked?this._queue.push(r):(this._locked=!0,t(()=>{this._locked=!1;let o=this._queue.shift();o&&o()}))};r()})}};function Le(e,t){let r=t instanceof Error?t.message:String(t);v.error(`Terminal Image Paste: ${r}`),c.error(`${e} command failed`,t)}function Et(e){let t=me(),r=be(t),o=ke();r.isToolAvailable().then(i=>{i||v.warning(`Terminal Image Paste: clipboard tool "${r.requiredTool()}" not found. Install it to use clipboard image pasting.`)}).catch(i=>{c.error("Failed to check tool availability",i)});let n=new Y,a=x.commands.registerCommand("terminalImgPaste.pasteImage",async()=>{let i=await n.acquire();try{if(!await r.isToolAvailable()){v.warning(`Terminal Image Paste: "${r.requiredTool()}" is not installed. Please install it to paste clipboard images.`);return}let m=x.workspace.getConfiguration("terminalImgPaste");if(m.get("warnOnRemote",!0)){let X=fe();if(X.remote&&X.type!=="wsl"&&await x.window.showWarningMessage("Clipboard images are saved locally. The pasted path may not be accessible from the remote terminal.","Paste Anyway","Cancel")!=="Paste Anyway")return}if(!await r.hasImage()){v.info("No image found in clipboard.");return}let{data:h,format:S}=await r.readImage();if(m.get("showPreview",!1)&&!await We(h,S)){v.statusBar("Image paste cancelled",3e3);return}let M=m.get("saveFormat","auto"),ae=await De(h,S,M,t),Oe=await o.save(ae.data,ae.format);oe(Oe),v.statusBar("Image pasted to terminal",3e3)}catch(l){Le("pasteImage",l)}finally{i()}}),s=x.commands.registerCommand("terminalImgPaste.sendPathToTerminal",async i=>{try{if(!i?.fsPath){v.error("Terminal Image Paste: No file selected.");return}oe(i.fsPath),v.statusBar("Path sent to terminal",3e3)}catch(l){Le("sendPathToTerminal",l)}});e.subscriptions.push(a,s),c.info(`Extension activated (platform: ${t.os}, WSL: ${t.isWSL})`)}function Tt(){c.info("Extension deactivating")}0&&(module.exports={activate,deactivate});
//# sourceMappingURL=extension.js.map
