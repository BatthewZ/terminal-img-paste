{
  "version": 3,
  "sources": ["../src/extension.ts", "../src/platform/detect.ts", "../src/util/exec.ts", "../src/clipboard/macosClipboard.ts", "../src/clipboard/macosOsascriptClipboard.ts", "../src/clipboard/linuxClipboard.ts", "../src/clipboard/powershellClipboard.ts", "../src/util/logger.ts", "../src/clipboard/windowsClipboard.ts", "../src/clipboard/wslClipboard.ts", "../src/clipboard/fallback.ts", "../src/clipboard/index.ts", "../src/storage/imageStore.ts", "../src/terminal/insertPath.ts", "../src/terminal/shellDetect.ts", "../src/util/mutex.ts"],
  "sourcesContent": ["import * as vscode from 'vscode';\nimport { detectPlatform } from './platform/detect';\nimport { createClipboardReader, ClipboardReader } from './clipboard/index';\nimport { createImageStore, ImageStore } from './storage/imageStore';\nimport { insertPathToTerminal } from './terminal/insertPath';\nimport { logger } from './util/logger';\nimport { Mutex } from './util/mutex';\n\nfunction handleCommandError(commandName: string, err: unknown): void {\n  const message = err instanceof Error ? err.message : String(err);\n  vscode.window.showErrorMessage(`Terminal Image Paste: ${message}`);\n  logger.error(`${commandName} command failed`, err);\n}\n\nexport function activate(context: vscode.ExtensionContext): void {\n  const platform = detectPlatform();\n  const reader: ClipboardReader = createClipboardReader(platform);\n  const imageStore: ImageStore = createImageStore();\n\n  // Check tool availability at activation \u2014 warn but don't block\n  reader.isToolAvailable().then((available) => {\n    if (!available) {\n      vscode.window.showWarningMessage(\n        `Terminal Image Paste: clipboard tool \"${reader.requiredTool()}\" not found. ` +\n          `Install it to use clipboard image pasting.`,\n      );\n    }\n  }).catch((err) => {\n    logger.error('Failed to check tool availability', err);\n  });\n\n  const pasteMutex = new Mutex();\n\n  const pasteImageDisposable = vscode.commands.registerCommand(\n    'terminalImgPaste.pasteImage',\n    async () => {\n      const release = await pasteMutex.acquire();\n      try {\n        const toolAvailable = await reader.isToolAvailable();\n        if (!toolAvailable) {\n          vscode.window.showWarningMessage(\n            `Terminal Image Paste: \"${reader.requiredTool()}\" is not installed. ` +\n              `Please install it to paste clipboard images.`,\n          );\n          return;\n        }\n\n        const hasImage = await reader.hasImage();\n        if (!hasImage) {\n          vscode.window.showInformationMessage('No image found in clipboard.');\n          return;\n        }\n\n        const { data, format } = await reader.readImage();\n        const filePath = await imageStore.save(data, format);\n        insertPathToTerminal(filePath);\n\n        vscode.window.setStatusBarMessage('Image pasted to terminal', 3000);\n      } catch (err) {\n        handleCommandError('pasteImage', err);\n      } finally {\n        release();\n      }\n    },\n  );\n\n  const sendPathDisposable = vscode.commands.registerCommand(\n    'terminalImgPaste.sendPathToTerminal',\n    async (uri: vscode.Uri) => {\n      try {\n        if (!uri?.fsPath) {\n          vscode.window.showErrorMessage(\n            'Terminal Image Paste: No file selected.',\n          );\n          return;\n        }\n\n        insertPathToTerminal(uri.fsPath);\n        vscode.window.setStatusBarMessage('Path sent to terminal', 3000);\n      } catch (err) {\n        handleCommandError('sendPathToTerminal', err);\n      }\n    },\n  );\n\n  context.subscriptions.push(pasteImageDisposable, sendPathDisposable);\n  logger.info(`Extension activated (platform: ${platform.os}, WSL: ${platform.isWSL})`);\n}\n\nexport function deactivate(): void {\n  logger.info('Extension deactivating');\n}\n", "import * as fs from \"fs\";\n\nexport interface PlatformInfo {\n  os: \"macos\" | \"linux\" | \"windows\";\n  isWSL: boolean;\n  displayServer: \"x11\" | \"wayland\" | \"unknown\";\n  powershellPath: string | null;\n}\n\nlet cached: PlatformInfo | null = null;\n\nfunction detectOS(): PlatformInfo[\"os\"] {\n  switch (process.platform) {\n    case \"darwin\":\n      return \"macos\";\n    case \"win32\":\n      return \"windows\";\n    default:\n      return \"linux\";\n  }\n}\n\nfunction detectWSL(): boolean {\n  try {\n    const procVersion = fs.readFileSync(\"/proc/version\", \"utf-8\");\n    return /microsoft/i.test(procVersion);\n  } catch {\n    return false;\n  }\n}\n\nfunction detectDisplayServer(\n  os: PlatformInfo[\"os\"],\n  isWSL: boolean\n): PlatformInfo[\"displayServer\"] {\n  if (os !== \"linux\") {\n    return \"unknown\";\n  }\n\n  // For WSL, check for WSLg (which provides X11/Wayland via /mnt/wslg/)\n  if (isWSL) {\n    if (process.env.WAYLAND_DISPLAY) {\n      return \"wayland\";\n    }\n    if (process.env.DISPLAY) {\n      return \"x11\";\n    }\n    return \"unknown\";\n  }\n\n  const sessionType = process.env.XDG_SESSION_TYPE;\n\n  if (sessionType === \"wayland\") {\n    return \"wayland\";\n  }\n  if (sessionType === \"x11\") {\n    return \"x11\";\n  }\n\n  // Fallback: WAYLAND_DISPLAY is set by Wayland compositors even when\n  // XDG_SESSION_TYPE is absent (containers, some desktop environments, etc.)\n  if (process.env.WAYLAND_DISPLAY) {\n    return \"wayland\";\n  }\n\n  return \"unknown\";\n}\n\nfunction detectPowershellPath(\n  os: PlatformInfo[\"os\"],\n  isWSL: boolean\n): string | null {\n  if (os === \"windows\") {\n    return \"powershell.exe\";\n  }\n\n  if (isWSL) {\n    const candidates = [\n      \"/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe\",\n      \"/mnt/c/Program Files/PowerShell/7/pwsh.exe\",\n    ];\n\n    for (const candidate of candidates) {\n      if (fs.existsSync(candidate)) {\n        return candidate;\n      }\n    }\n\n    // Fall back to powershell.exe which may be in PATH via interop\n    return \"powershell.exe\";\n  }\n\n  return null;\n}\n\nexport function detectPlatform(): PlatformInfo {\n  if (cached) {\n    return cached;\n  }\n\n  const os = detectOS();\n  const isWSL = os === \"linux\" ? detectWSL() : false;\n  const displayServer = detectDisplayServer(os, isWSL);\n  const powershellPath = detectPowershellPath(os, isWSL);\n\n  cached = { os, isWSL, displayServer, powershellPath };\n  return cached;\n}\n", "import { execFile } from \"child_process\";\n\nconst DEFAULT_TIMEOUT = 10_000;\nconst DEFAULT_MAX_BUFFER = 10 * 1024 * 1024; // 10 MB\nconst DEFAULT_MAX_BUFFER_BINARY = 50 * 1024 * 1024; // 50 MB\n\nfunction exitCode(error: Error): string | number {\n  if (\"code\" in error && typeof error.code === \"number\") {\n    return error.code;\n  }\n  return (error as NodeJS.ErrnoException).code ?? \"unknown\";\n}\n\nexport interface ExecOptions {\n  timeout?: number;\n  cwd?: string;\n  maxBuffer?: number;\n}\n\nexport interface ExecResult {\n  stdout: string;\n  stderr: string;\n}\n\nexport interface ExecBufferResult {\n  stdout: Buffer;\n  stderr: string;\n}\n\n/**\n * Execute a command with arguments, returning stdout and stderr as strings.\n * Uses `execFile` (no shell) to avoid shell-injection vulnerabilities.\n */\nexport function exec(\n  command: string,\n  args: string[],\n  options?: ExecOptions,\n): Promise<ExecResult> {\n  return new Promise((resolve, reject) => {\n    execFile(\n      command,\n      args,\n      {\n        encoding: \"utf-8\",\n        timeout: options?.timeout ?? DEFAULT_TIMEOUT,\n        maxBuffer: options?.maxBuffer ?? DEFAULT_MAX_BUFFER,\n        cwd: options?.cwd,\n      },\n      (error, stdout, stderr) => {\n        if (error) {\n          reject(\n            new Error(\n              `Command \"${command}\" failed (exit code ${exitCode(error)}): ${stderr || error.message}`,\n            ),\n          );\n          return;\n        }\n        resolve({ stdout, stderr });\n      },\n    );\n  });\n}\n\n/**\n * Execute a command with arguments, returning stdout as a raw Buffer and\n * stderr as a string.  Useful for reading binary data (e.g. clipboard\n * images) from tools that write to stdout.\n *\n * Uses `execFile` (no shell) to avoid shell-injection vulnerabilities.\n */\nexport function execBuffer(\n  command: string,\n  args: string[],\n  options?: ExecOptions,\n): Promise<ExecBufferResult> {\n  return new Promise((resolve, reject) => {\n    execFile(\n      command,\n      args,\n      {\n        encoding: \"buffer\",\n        timeout: options?.timeout ?? DEFAULT_TIMEOUT,\n        maxBuffer: options?.maxBuffer ?? DEFAULT_MAX_BUFFER_BINARY,\n        cwd: options?.cwd,\n      },\n      (error, stdout, stderr) => {\n        // stderr comes back as a Buffer when encoding is \"buffer\"\n        const stderrStr =\n          stderr instanceof Buffer ? stderr.toString(\"utf-8\") : String(stderr);\n        if (error) {\n          reject(\n            new Error(\n              `Command \"${command}\" failed (exit code ${exitCode(error)}): ${stderrStr || error.message}`,\n            ),\n          );\n          return;\n        }\n        resolve({ stdout, stderr: stderrStr });\n      },\n    );\n  });\n}\n", "import { ClipboardReader, ClipboardFormat, ClipboardImageResult } from \"./types\";\nimport { exec, execBuffer } from \"../util/exec\";\n\n/** Fetch raw clipboard info string from osascript (shared by macOS readers). */\nexport async function getClipboardInfo(): Promise<string> {\n  const { stdout } = await exec(\"osascript\", [\"-e\", \"clipboard info\"]);\n  return stdout;\n}\n\n/** Parse macOS `clipboard info` output and return detected formats in preference order. */\nexport function parseClipboardFormats(info: string): ClipboardFormat[] {\n  const formats: ClipboardFormat[] = [];\n  if (info.includes(\"\u00ABclass PNGf\u00BB\")) {\n    formats.push(\"png\");\n  }\n  if (info.includes(\"\u00ABclass JPEG\u00BB\") || info.includes(\"\u00ABclass JPEf\u00BB\")) {\n    formats.push(\"jpeg\");\n  }\n  if (info.includes(\"\u00ABclass TIFF\u00BB\")) {\n    formats.push(\"tiff\");\n  }\n  if (info.includes(\"\u00ABclass BMP \u00BB\") || info.includes(\"\u00ABclass BMPf\u00BB\")) {\n    formats.push(\"bmp\");\n  }\n  return formats;\n}\n\nexport class MacosClipboardReader implements ClipboardReader {\n  requiredTool(): string {\n    return \"pngpaste\";\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    try {\n      await exec(\"which\", [\"pngpaste\"]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async hasImage(): Promise<boolean> {\n    try {\n      const info = await getClipboardInfo();\n      return parseClipboardFormats(info).length > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  async detectFormat(): Promise<ClipboardFormat> {\n    const info = await getClipboardInfo();\n    const formats = parseClipboardFormats(info);\n    if (formats.length > 0) {\n      return formats[0];\n    }\n    throw new Error(\"No image found in clipboard\");\n  }\n\n  async readImage(): Promise<ClipboardImageResult> {\n    const imageAvailable = await this.hasImage();\n    if (!imageAvailable) {\n      throw new Error(\"No image found in clipboard\");\n    }\n    const { stdout } = await execBuffer(\"pngpaste\", [\"-\"]);\n    return { data: stdout, format: \"png\" };\n  }\n}\n", "import { ClipboardReader, ClipboardFormat, ClipboardImageResult } from \"./types\";\nimport { execBuffer } from \"../util/exec\";\nimport { getClipboardInfo, parseClipboardFormats } from \"./macosClipboard\";\n\n/** Map from ClipboardFormat to the osascript class name used for clipboard coercion. */\nconst FORMAT_TO_OSASCRIPT_CLASS: Record<string, string> = {\n  png: \"PNGf\",\n  jpeg: \"JPEG\",\n  tiff: \"TIFF\",\n};\n\n/**\n * macOS clipboard reader using only osascript.\n * Used as a fallback when pngpaste is not installed.\n */\nexport class MacosOsascriptClipboardReader implements ClipboardReader {\n  requiredTool(): string {\n    return \"osascript (built-in)\";\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    return process.platform === \"darwin\";\n  }\n\n  async hasImage(): Promise<boolean> {\n    try {\n      const info = await getClipboardInfo();\n      return parseClipboardFormats(info).length > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  async detectFormat(): Promise<ClipboardFormat> {\n    const info = await getClipboardInfo();\n    const formats = parseClipboardFormats(info);\n    if (formats.length > 0) {\n      return formats[0];\n    }\n    throw new Error(\"No image found in clipboard\");\n  }\n\n  async readImage(): Promise<ClipboardImageResult> {\n    const format = await this.detectFormat();\n    const hasNativeClass = format in FORMAT_TO_OSASCRIPT_CLASS;\n    const osClass = hasNativeClass ? FORMAT_TO_OSASCRIPT_CLASS[format] : \"PNGf\";\n    const resolvedFormat = hasNativeClass ? format : \"png\";\n\n    const { stdout } = await execBuffer(\"osascript\", [\n      \"-e\",\n      `set imgData to (the clipboard as \u00ABclass ${osClass}\u00BB)`,\n      \"-e\",\n      \"return imgData\",\n    ]);\n    return { data: stdout, format: resolvedFormat };\n  }\n}\n", "import { ClipboardReader, ClipboardFormat, ClipboardImageResult } from \"./types\";\nimport { PlatformInfo } from \"../platform/detect\";\nimport { exec, execBuffer } from \"../util/exec\";\n\n/** MIME type to ClipboardFormat mapping, in preference order. */\nconst MIME_FORMAT_MAP: Array<[string, ClipboardFormat]> = [\n  [\"image/png\", \"png\"],\n  [\"image/jpeg\", \"jpeg\"],\n  [\"image/webp\", \"webp\"],\n  [\"image/tiff\", \"tiff\"],\n  [\"image/bmp\", \"bmp\"],\n  [\"image/x-bmp\", \"bmp\"],\n];\n\n/** Parse a list of MIME types and return the best matching ClipboardFormat. */\nfunction detectFormatFromMimeTypes(\n  mimeList: string,\n): ClipboardFormat | null {\n  for (const [mime, format] of MIME_FORMAT_MAP) {\n    if (mimeList.includes(mime)) {\n      return format;\n    }\n  }\n  // Check for any unrecognized image/* type\n  if (/^image\\//m.test(mimeList)) {\n    return \"unknown\";\n  }\n  return null;\n}\n\nexport class LinuxClipboardReader implements ClipboardReader {\n  private displayServer: PlatformInfo[\"displayServer\"];\n\n  constructor(displayServer: PlatformInfo[\"displayServer\"]) {\n    this.displayServer = displayServer;\n  }\n\n  private isWayland(): boolean {\n    return this.displayServer === \"wayland\";\n  }\n\n  requiredTool(): string {\n    if (this.isWayland()) {\n      return \"wl-clipboard (wl-paste)\";\n    }\n    return \"xclip\";\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    try {\n      if (this.isWayland()) {\n        await exec(\"which\", [\"wl-paste\"]);\n      } else {\n        await exec(\"which\", [\"xclip\"]);\n      }\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /** Get the list of available clipboard types/targets. */\n  private async getClipboardTypes(): Promise<string> {\n    if (this.isWayland()) {\n      const { stdout } = await exec(\"wl-paste\", [\"--list-types\"]);\n      return stdout;\n    } else {\n      const { stdout } = await exec(\"xclip\", [\n        \"-selection\",\n        \"clipboard\",\n        \"-t\",\n        \"TARGETS\",\n        \"-o\",\n      ]);\n      return stdout;\n    }\n  }\n\n  async hasImage(): Promise<boolean> {\n    try {\n      const types = await this.getClipboardTypes();\n      return /^image\\//m.test(types);\n    } catch {\n      return false;\n    }\n  }\n\n  async detectFormat(): Promise<ClipboardFormat> {\n    const types = await this.getClipboardTypes();\n    const format = detectFormatFromMimeTypes(types);\n    if (format !== null) {\n      return format;\n    }\n    throw new Error(\"No image found in clipboard\");\n  }\n\n  /** Map a ClipboardFormat to its MIME type string, using MIME_FORMAT_MAP as source of truth. */\n  private formatToMime(format: ClipboardFormat): string {\n    const entry = MIME_FORMAT_MAP.find(([, f]) => f === format);\n    return entry ? entry[0] : \"image/png\";\n  }\n\n  async readImage(): Promise<ClipboardImageResult> {\n    const format = await this.detectFormat();\n    const mime = this.formatToMime(format);\n    const resolvedFormat = format === \"unknown\" ? \"png\" : format;\n\n    const { stdout } = this.isWayland()\n      ? await execBuffer(\"wl-paste\", [\"--type\", mime])\n      : await execBuffer(\"xclip\", [\n          \"-selection\",\n          \"clipboard\",\n          \"-t\",\n          mime,\n          \"-o\",\n        ]);\n    return { data: stdout, format: resolvedFormat };\n  }\n}\n", "import * as fs from \"fs\";\nimport { ClipboardReader, ClipboardFormat, ClipboardImageResult } from \"./types\";\nimport { exec } from \"../util/exec\";\nimport { logger } from \"../util/logger\";\n\nconst PS_HAS_IMAGE =\n  \"Add-Type -AssemblyName System.Windows.Forms; if ([System.Windows.Forms.Clipboard]::ContainsImage()) { echo 'yes' } else { echo 'no' }\";\n\nconst PS_READ_IMAGE =\n  \"Add-Type -AssemblyName System.Windows.Forms; $img = [System.Windows.Forms.Clipboard]::GetImage(); if ($img -eq $null) { exit 1 }; $tmp = [System.IO.Path]::GetTempFileName(); $img.Save($tmp, [System.Drawing.Imaging.ImageFormat]::Png); Write-Output $tmp\";\n\n/**\n * Shared base for clipboard readers that use PowerShell to access the\n * Windows clipboard (native Windows and WSL).\n */\nexport abstract class PowerShellClipboardReader implements ClipboardReader {\n  protected abstract get powershellExe(): string;\n\n  abstract requiredTool(): string;\n\n  /** Convert a Windows-style temp path to a path readable by the current OS.\n   *  On native Windows this is an identity operation; on WSL it runs wslpath. */\n  protected abstract resolveTempPath(windowsPath: string): Promise<string>;\n\n  async isToolAvailable(): Promise<boolean> {\n    try {\n      await exec(this.powershellExe, [\"-Command\", \"echo ok\"]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async hasImage(): Promise<boolean> {\n    try {\n      const result = await exec(this.powershellExe, [\n        \"-Command\",\n        PS_HAS_IMAGE,\n      ]);\n      return result.stdout.trim() === \"yes\";\n    } catch {\n      return false;\n    }\n  }\n\n  async detectFormat(): Promise<ClipboardFormat> {\n    const has = await this.hasImage();\n    if (!has) {\n      throw new Error(\"No image found in clipboard\");\n    }\n    // PowerShell's System.Drawing always re-encodes to PNG\n    return \"png\";\n  }\n\n  async readImage(): Promise<ClipboardImageResult> {\n    const has = await this.hasImage();\n    if (!has) {\n      throw new Error(\"No image found in clipboard\");\n    }\n\n    const result = await exec(this.powershellExe, [\n      \"-Command\",\n      PS_READ_IMAGE,\n    ]);\n\n    const localPath = await this.resolveTempPath(result.stdout.trim());\n    try {\n      const data = await fs.promises.readFile(localPath);\n      return { data, format: \"png\" };\n    } finally {\n      fs.promises.unlink(localPath).catch((err) => {\n        logger.warn(`Failed to clean up temp file: ${localPath}`, err);\n      });\n    }\n  }\n}\n", "import * as vscode from 'vscode';\n\nexport interface Logger {\n  info(message: string): void;\n  warn(message: string, err?: unknown): void;\n  error(message: string, err?: unknown): void;\n  show(): void;\n}\n\nfunction timestamp(): string {\n  const now = new Date();\n  const h = String(now.getHours()).padStart(2, '0');\n  const m = String(now.getMinutes()).padStart(2, '0');\n  const s = String(now.getSeconds()).padStart(2, '0');\n  const ms = String(now.getMilliseconds()).padStart(3, '0');\n  return `[${h}:${m}:${s}.${ms}]`;\n}\n\nexport function createLogger(name: string): Logger {\n  const channel = vscode.window.createOutputChannel(name);\n\n  return {\n    info(message: string): void {\n      channel.appendLine(`${timestamp()} [INFO] ${message}`);\n    },\n\n    warn(message: string, err?: unknown): void {\n      let line = `${timestamp()} [WARN] ${message}`;\n      if (err !== undefined) {\n        if (err instanceof Error && err.stack) {\n          line += `\\n${err.stack}`;\n        } else {\n          line += `\\n${String(err)}`;\n        }\n      }\n      channel.appendLine(line);\n    },\n\n    error(message: string, err?: unknown): void {\n      let line = `${timestamp()} [ERROR] ${message}`;\n      if (err !== undefined) {\n        if (err instanceof Error && err.stack) {\n          line += `\\n${err.stack}`;\n        } else {\n          line += `\\n${String(err)}`;\n        }\n      }\n      channel.appendLine(line);\n    },\n\n    show(): void {\n      channel.show();\n    },\n  };\n}\n\nexport const logger: Logger = createLogger('Terminal Image Paste');\n", "import { PowerShellClipboardReader } from \"./powershellClipboard\";\n\nexport class WindowsClipboardReader extends PowerShellClipboardReader {\n  protected get powershellExe(): string {\n    return \"powershell.exe\";\n  }\n\n  requiredTool(): string {\n    return \"PowerShell (built-in)\";\n  }\n\n  protected async resolveTempPath(windowsPath: string): Promise<string> {\n    return windowsPath;\n  }\n}\n", "import { PowerShellClipboardReader } from \"./powershellClipboard\";\nimport { PlatformInfo } from \"../platform/detect\";\nimport { exec } from \"../util/exec\";\n\nexport class WslClipboardReader extends PowerShellClipboardReader {\n  private readonly psPath: string;\n\n  constructor(platform: PlatformInfo) {\n    super();\n    this.psPath = platform.powershellPath ?? \"powershell.exe\";\n  }\n\n  protected get powershellExe(): string {\n    return this.psPath;\n  }\n\n  requiredTool(): string {\n    return \"PowerShell (via WSL interop)\";\n  }\n\n  protected async resolveTempPath(windowsPath: string): Promise<string> {\n    const result = await exec(\"wslpath\", [\"-u\", windowsPath]);\n    return result.stdout.trim();\n  }\n}\n", "import { ClipboardReader, ClipboardFormat, ClipboardImageResult } from \"./types\";\n\n/**\n * Tries each reader in order. The first reader whose operation succeeds wins.\n * If all readers fail, throws an aggregate error with details from each.\n */\nexport class FallbackClipboardReader implements ClipboardReader {\n  private readers: ClipboardReader[];\n\n  constructor(readers: ClipboardReader[]) {\n    if (readers.length === 0) {\n      throw new Error(\"FallbackClipboardReader requires at least one reader\");\n    }\n    this.readers = readers;\n  }\n\n  requiredTool(): string {\n    return this.readers.map((r) => r.requiredTool()).join(\" or \");\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    for (const reader of this.readers) {\n      if (await reader.isToolAvailable()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  async hasImage(): Promise<boolean> {\n    for (const reader of this.readers) {\n      try {\n        if (await reader.hasImage()) {\n          return true;\n        }\n      } catch {\n        continue;\n      }\n    }\n    return false;\n  }\n\n  async detectFormat(): Promise<ClipboardFormat> {\n    const errors: Error[] = [];\n    for (const reader of this.readers) {\n      try {\n        return await reader.detectFormat();\n      } catch (err) {\n        errors.push(err instanceof Error ? err : new Error(String(err)));\n      }\n    }\n    throw new AggregateError(\n      errors,\n      `All clipboard readers failed to detect format: ${errors.map((e) => e.message).join(\"; \")}`,\n    );\n  }\n\n  async readImage(): Promise<ClipboardImageResult> {\n    const errors: Error[] = [];\n    for (const reader of this.readers) {\n      try {\n        if (!(await reader.isToolAvailable())) {\n          errors.push(\n            new Error(`${reader.requiredTool()}: tool not available`),\n          );\n          continue;\n        }\n        return await reader.readImage();\n      } catch (err) {\n        errors.push(err instanceof Error ? err : new Error(String(err)));\n      }\n    }\n    throw new AggregateError(\n      errors,\n      `All clipboard readers failed: ${errors.map((e) => e.message).join(\"; \")}`,\n    );\n  }\n}\n", "import { PlatformInfo } from \"../platform/detect\";\nimport { ClipboardReader } from \"./types\";\nimport { MacosClipboardReader } from \"./macosClipboard\";\nimport { MacosOsascriptClipboardReader } from \"./macosOsascriptClipboard\";\nimport { LinuxClipboardReader } from \"./linuxClipboard\";\nimport { WindowsClipboardReader } from \"./windowsClipboard\";\nimport { WslClipboardReader } from \"./wslClipboard\";\nimport { FallbackClipboardReader } from \"./fallback\";\n\nexport { ClipboardReader } from \"./types\";\n\nexport function createClipboardReader(platform: PlatformInfo): ClipboardReader {\n  if (platform.isWSL) {\n    const readers: ClipboardReader[] = [new WslClipboardReader(platform)];\n\n    if (platform.displayServer === \"x11\" || platform.displayServer === \"wayland\") {\n      readers.push(new LinuxClipboardReader(platform.displayServer));\n    }\n\n    return readers.length === 1\n      ? readers[0]\n      : new FallbackClipboardReader(readers);\n  }\n\n  switch (platform.os) {\n    case \"macos\":\n      return new FallbackClipboardReader([\n        new MacosClipboardReader(),\n        new MacosOsascriptClipboardReader(),\n      ]);\n    case \"windows\":\n      return new WindowsClipboardReader();\n    case \"linux\": {\n      const primary = new LinuxClipboardReader(platform.displayServer);\n      const fallbackDS =\n        platform.displayServer === \"wayland\" ? \"x11\" : \"wayland\";\n      const fallback = new LinuxClipboardReader(fallbackDS);\n      return new FallbackClipboardReader([primary, fallback]);\n    }\n  }\n}\n", "import * as fs from 'fs';\nimport * as path from 'path';\nimport * as vscode from 'vscode';\nimport { logger } from '../util/logger';\nimport type { ClipboardFormat } from '../clipboard/types';\n\nexport interface ImageStore {\n  /** Save an image buffer to the image folder. Returns the absolute file path. */\n  save(imageBuffer: Buffer, format?: ClipboardFormat): Promise<string>;\n\n  /** Delete the oldest images if count exceeds maxImages setting. */\n  cleanup(): Promise<void>;\n\n  /** Ensure the image folder is listed in .gitignore (if autoGitIgnore is enabled). */\n  ensureGitIgnored(): Promise<void>;\n}\n\nconst DEFAULT_FOLDER_NAME = '.tip-images';\n\n/** All image file extensions managed by this store. */\nconst IMAGE_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.tiff', '.bmp', '.webp'];\n\n/** Map from ClipboardFormat to file extension. */\nfunction formatToExtension(format: ClipboardFormat): string {\n  switch (format) {\n    case 'jpeg':\n      return '.jpg';\n    case 'tiff':\n      return '.tiff';\n    case 'bmp':\n      return '.bmp';\n    case 'webp':\n      return '.webp';\n    case 'png':\n    case 'unknown':\n    default:\n      return '.png';\n  }\n}\n\n/** First 8 bytes of every valid PNG file. */\nconst PNG_SIGNATURE = Buffer.from([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n\n/** Validate image data matches the expected format's magic bytes. */\nfunction validateImage(buffer: Buffer, format: ClipboardFormat): void {\n  switch (format) {\n    case 'png':\n      if (buffer.length < PNG_SIGNATURE.length || !buffer.subarray(0, PNG_SIGNATURE.length).equals(PNG_SIGNATURE)) {\n        throw new Error('Clipboard data is not a valid PNG image');\n      }\n      break;\n    case 'jpeg':\n      if (buffer.length < 2 || buffer[0] !== 0xff || buffer[1] !== 0xd8) {\n        throw new Error('Clipboard data is not a valid JPEG image');\n      }\n      break;\n    case 'bmp':\n      if (buffer.length < 2 || buffer[0] !== 0x42 || buffer[1] !== 0x4d) {\n        throw new Error('Clipboard data is not a valid BMP image');\n      }\n      break;\n    case 'webp':\n      if (\n        buffer.length < 12 ||\n        buffer.subarray(0, 4).toString('ascii') !== 'RIFF' ||\n        buffer.subarray(8, 12).toString('ascii') !== 'WEBP'\n      ) {\n        throw new Error('Clipboard data is not a valid WebP image');\n      }\n      break;\n    case 'tiff':\n      if (\n        buffer.length < 2 ||\n        !(\n          (buffer[0] === 0x49 && buffer[1] === 0x49) ||\n          (buffer[0] === 0x4d && buffer[1] === 0x4d)\n        )\n      ) {\n        throw new Error('Clipboard data is not a valid TIFF image');\n      }\n      break;\n    case 'unknown':\n      logger.warn('Skipping image validation for unknown format');\n      break;\n  }\n}\n\nfunction getConfig(): vscode.WorkspaceConfiguration {\n  return vscode.workspace.getConfiguration('terminalImgPaste');\n}\n\nfunction getWorkspaceRoot(): string {\n  const folders = vscode.workspace.workspaceFolders;\n  if (!folders || folders.length === 0) {\n    vscode.window.showErrorMessage(\n      'Terminal Image Paste: No workspace folder is open. Please open a folder first.',\n    );\n    throw new Error('No workspace folder is open');\n  }\n  return folders[0].uri.fsPath;\n}\n\nfunction getFolderName(): string {\n  return getConfig().get<string>('folderName', DEFAULT_FOLDER_NAME);\n}\n\nfunction getImageFolderPath(): string {\n  const root = getWorkspaceRoot();\n  const folderName = getFolderName();\n  const resolved = path.resolve(root, folderName);\n  if (!resolved.startsWith(root + path.sep)) {\n    throw new Error(\n      `Configured folderName \"${folderName}\" must resolve to a subdirectory of the workspace root`,\n    );\n  }\n  return resolved;\n}\n\nfunction generateFileName(format: ClipboardFormat): string {\n  const now = new Date();\n  const y = now.getFullYear();\n  const mo = String(now.getMonth() + 1).padStart(2, '0');\n  const d = String(now.getDate()).padStart(2, '0');\n  const h = String(now.getHours()).padStart(2, '0');\n  const mi = String(now.getMinutes()).padStart(2, '0');\n  const s = String(now.getSeconds()).padStart(2, '0');\n  const ms = String(now.getMilliseconds()).padStart(3, '0');\n  const ext = formatToExtension(format);\n  return `img-${y}-${mo}-${d}T${h}-${mi}-${s}-${ms}${ext}`;\n}\n\nexport function createImageStore(): ImageStore {\n  return {\n    async save(imageBuffer: Buffer, format: ClipboardFormat = 'png'): Promise<string> {\n      validateImage(imageBuffer, format);\n\n      const folder = getImageFolderPath();\n      await fs.promises.mkdir(folder, { recursive: true });\n\n      const fileName = generateFileName(format);\n      const filePath = path.join(folder, fileName);\n      await fs.promises.writeFile(filePath, imageBuffer, { mode: 0o600 });\n\n      logger.info(`Saved image: ${filePath}`);\n\n      await this.cleanup();\n      await this.ensureGitIgnored();\n\n      return filePath;\n    },\n\n    async cleanup(): Promise<void> {\n      const config = getConfig();\n      const rawMaxImages = config.get<number>('maxImages', 20);\n      const maxImages =\n        Number.isInteger(rawMaxImages) && rawMaxImages > 0\n          ? rawMaxImages\n          : 20;\n      const folder = getImageFolderPath();\n\n      let entries: string[];\n      try {\n        entries = await fs.promises.readdir(folder);\n      } catch {\n        return;\n      }\n\n      const imageFiles = entries\n        .filter((f) => IMAGE_EXTENSIONS.some((ext) => f.endsWith(ext)))\n        .sort();\n\n      if (imageFiles.length <= maxImages) {\n        return;\n      }\n\n      const toDelete = imageFiles.slice(0, imageFiles.length - maxImages);\n      for (const file of toDelete) {\n        const filePath = path.join(folder, file);\n        try {\n          await fs.promises.unlink(filePath);\n          logger.info(`Deleted old image: ${filePath}`);\n        } catch (err) {\n          logger.warn(`Failed to delete old image: ${filePath}`, err);\n        }\n      }\n    },\n\n    async ensureGitIgnored(): Promise<void> {\n      const config = getConfig();\n      if (!config.get<boolean>('autoGitIgnore', true)) {\n        return;\n      }\n\n      const folderName = getFolderName();\n      const workspaceRoot = getWorkspaceRoot();\n      const gitignorePath = path.join(workspaceRoot, '.gitignore');\n\n      let content: string;\n      try {\n        content = await fs.promises.readFile(gitignorePath, 'utf-8');\n      } catch {\n        await fs.promises.writeFile(gitignorePath, folderName + '\\n', 'utf-8');\n        logger.info(`Created .gitignore with ${folderName}`);\n        return;\n      }\n\n      const lines = content.split('\\n').map((line) => line.trim());\n      if (lines.includes(folderName)) {\n        return;\n      }\n\n      const suffix = content.endsWith('\\n') ? '' : '\\n';\n      await fs.promises.writeFile(\n        gitignorePath,\n        content + suffix + folderName + '\\n',\n        'utf-8',\n      );\n      logger.info(`Added ${folderName} to .gitignore`);\n    },\n  };\n}\n", "import * as vscode from 'vscode';\nimport { logger } from '../util/logger';\nimport { detectShellType, type ShellType } from './shellDetect';\n\n/**\n * Quote a file path for safe insertion into a specific shell.\n */\nexport function quotePath(filePath: string, shell: ShellType): string {\n  switch (shell) {\n    case 'fish':\n      // Fish uses single quotes but escapes ' with \\'\n      return \"'\" + filePath.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\'\") + \"'\";\n    case 'powershell':\n      // PowerShell uses double quotes; escape ` with ``, $ with `$, \" with `\"\n      return '\"' + filePath.replace(/`/g, '``').replace(/\\$/g, '`$').replace(/\"/g, '`\"') + '\"';\n    case 'cmd':\n      // cmd uses double quotes; escape % with %%, \" with \"\"\n      return '\"' + filePath.replace(/%/g, '%%').replace(/\"/g, '\"\"') + '\"';\n    case 'bash':\n    case 'zsh':\n    case 'unknown':\n    default:\n      // Single-quote the path, escape embedded single quotes with '\\''\n      return \"'\" + filePath.replace(/'/g, \"'\\\\''\") + \"'\";\n  }\n}\n\n/**\n * Send a file path to the active terminal.\n * Detects the shell type and applies the correct quoting strategy.\n * Reads `sendNewline` setting to decide whether to append a newline.\n */\nexport function insertPathToTerminal(filePath: string): void {\n  const terminal = vscode.window.activeTerminal;\n  if (!terminal) {\n    vscode.window.showErrorMessage(\n      'Terminal Image Paste: No active terminal. Please open a terminal first.',\n    );\n    return;\n  }\n\n  const shellType = detectShellType(terminal);\n  const text = quotePath(filePath, shellType);\n\n  const config = vscode.workspace.getConfiguration('terminalImgPaste');\n  const addNewline = config.get<boolean>('sendNewline', false);\n\n  terminal.sendText(text, addNewline);\n  logger.info(`Inserted path into terminal (${shellType}): ${text}`);\n}\n", "import * as vscode from 'vscode';\nimport * as path from 'path';\n\nexport type ShellType = 'bash' | 'zsh' | 'fish' | 'powershell' | 'cmd' | 'unknown';\n\nconst shellPatterns: Array<{ pattern: RegExp; type: ShellType }> = [\n  { pattern: /\\bbash\\b/i, type: 'bash' },\n  { pattern: /\\bzsh\\b/i, type: 'zsh' },\n  { pattern: /\\bfish\\b/i, type: 'fish' },\n  { pattern: /\\b(?:pwsh|powershell)\\b/i, type: 'powershell' },\n  { pattern: /\\bcmd\\b/i, type: 'cmd' },\n];\n\nfunction matchShell(shellPath: string): ShellType {\n  const base = path.basename(shellPath).replace(/\\.exe$/i, '');\n  for (const { pattern, type } of shellPatterns) {\n    if (pattern.test(base)) {\n      return type;\n    }\n  }\n  return 'unknown';\n}\n\nexport function detectShellType(terminal: vscode.Terminal): ShellType {\n  // 1. Check terminal's explicit shell path\n  const shellPath = (terminal.creationOptions as vscode.TerminalOptions)?.shellPath;\n  if (shellPath) {\n    return matchShell(shellPath);\n  }\n\n  // 2. Fall back to SHELL environment variable\n  const envShell = process.env.SHELL;\n  if (envShell) {\n    return matchShell(envShell);\n  }\n\n  // 3. Windows default: PowerShell\n  if (process.platform === 'win32') {\n    return 'powershell';\n  }\n\n  return 'unknown';\n}\n", "/**\n * Simple async mutex for serializing operations.\n * Usage:\n *   const release = await mutex.acquire();\n *   try { ... } finally { release(); }\n */\nexport class Mutex {\n  private _queue: Array<() => void> = [];\n  private _locked = false;\n\n  acquire(): Promise<() => void> {\n    return new Promise<() => void>((resolve) => {\n      const tryAcquire = () => {\n        if (!this._locked) {\n          this._locked = true;\n          resolve(() => {\n            this._locked = false;\n            const next = this._queue.shift();\n            if (next) {\n              next();\n            }\n          });\n        } else {\n          this._queue.push(tryAcquire);\n        }\n      };\n      tryAcquire();\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["extension_exports", "__export", "activate", "deactivate", "__toCommonJS", "vscode", "fs", "cached", "detectOS", "detectWSL", "procVersion", "detectDisplayServer", "os", "isWSL", "sessionType", "detectPowershellPath", "candidates", "candidate", "detectPlatform", "displayServer", "powershellPath", "import_child_process", "DEFAULT_TIMEOUT", "DEFAULT_MAX_BUFFER", "DEFAULT_MAX_BUFFER_BINARY", "exitCode", "error", "exec", "command", "args", "options", "resolve", "reject", "stdout", "stderr", "execBuffer", "stderrStr", "getClipboardInfo", "stdout", "exec", "parseClipboardFormats", "info", "formats", "MacosClipboardReader", "execBuffer", "FORMAT_TO_OSASCRIPT_CLASS", "MacosOsascriptClipboardReader", "info", "getClipboardInfo", "parseClipboardFormats", "formats", "format", "hasNativeClass", "osClass", "resolvedFormat", "stdout", "execBuffer", "MIME_FORMAT_MAP", "detectFormatFromMimeTypes", "mimeList", "mime", "format", "LinuxClipboardReader", "displayServer", "exec", "stdout", "types", "entry", "f", "resolvedFormat", "execBuffer", "fs", "vscode", "timestamp", "now", "h", "m", "s", "ms", "createLogger", "name", "channel", "message", "err", "line", "logger", "PS_HAS_IMAGE", "PS_READ_IMAGE", "PowerShellClipboardReader", "exec", "result", "localPath", "err", "logger", "WindowsClipboardReader", "PowerShellClipboardReader", "windowsPath", "WslClipboardReader", "PowerShellClipboardReader", "platform", "windowsPath", "exec", "FallbackClipboardReader", "readers", "r", "reader", "errors", "err", "e", "createClipboardReader", "platform", "readers", "WslClipboardReader", "LinuxClipboardReader", "FallbackClipboardReader", "MacosClipboardReader", "MacosOsascriptClipboardReader", "WindowsClipboardReader", "primary", "fallbackDS", "fallback", "fs", "path", "vscode", "DEFAULT_FOLDER_NAME", "IMAGE_EXTENSIONS", "formatToExtension", "format", "PNG_SIGNATURE", "validateImage", "buffer", "logger", "getConfig", "getWorkspaceRoot", "folders", "getFolderName", "getImageFolderPath", "root", "folderName", "resolved", "generateFileName", "now", "y", "mo", "d", "h", "mi", "s", "ms", "ext", "createImageStore", "imageBuffer", "folder", "fileName", "filePath", "rawMaxImages", "maxImages", "entries", "imageFiles", "f", "toDelete", "file", "err", "workspaceRoot", "gitignorePath", "content", "line", "suffix", "vscode", "path", "shellPatterns", "matchShell", "shellPath", "base", "pattern", "type", "detectShellType", "terminal", "envShell", "quotePath", "filePath", "shell", "insertPathToTerminal", "terminal", "shellType", "detectShellType", "text", "addNewline", "logger", "Mutex", "resolve", "tryAcquire", "next", "handleCommandError", "commandName", "err", "message", "logger", "activate", "context", "platform", "detectPlatform", "reader", "createClipboardReader", "imageStore", "createImageStore", "available", "pasteMutex", "Mutex", "pasteImageDisposable", "release", "data", "format", "filePath", "insertPathToTerminal", "sendPathDisposable", "uri", "deactivate"]
}
