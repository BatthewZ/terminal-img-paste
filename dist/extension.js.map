{
  "version": 3,
  "sources": ["../src/extension.ts", "../src/platform/detect.ts", "../src/util/exec.ts", "../src/clipboard/macosClipboard.ts", "../src/clipboard/linuxClipboard.ts", "../src/clipboard/powershellClipboard.ts", "../src/clipboard/windowsClipboard.ts", "../src/clipboard/wslClipboard.ts", "../src/clipboard/index.ts", "../src/storage/imageStore.ts", "../src/util/logger.ts", "../src/terminal/insertPath.ts"],
  "sourcesContent": ["import * as vscode from 'vscode';\nimport { detectPlatform } from './platform/detect';\nimport { createClipboardReader, ClipboardReader } from './clipboard/index';\nimport { createImageStore, ImageStore } from './storage/imageStore';\nimport { insertPathToTerminal } from './terminal/insertPath';\nimport { logger } from './util/logger';\n\nfunction handleCommandError(commandName: string, err: unknown): void {\n  const message = err instanceof Error ? err.message : String(err);\n  vscode.window.showErrorMessage(`Terminal Image Paste: ${message}`);\n  logger.error(`${commandName} command failed`, err);\n}\n\nexport function activate(context: vscode.ExtensionContext): void {\n  const platform = detectPlatform();\n  const reader: ClipboardReader = createClipboardReader(platform);\n  const imageStore: ImageStore = createImageStore();\n\n  // Check tool availability at activation \u2014 warn but don't block\n  reader.isToolAvailable().then((available) => {\n    if (!available) {\n      vscode.window.showWarningMessage(\n        `Terminal Image Paste: clipboard tool \"${reader.requiredTool()}\" not found. ` +\n          `Install it to use clipboard image pasting.`,\n      );\n    }\n  }).catch((err) => {\n    logger.error('Failed to check tool availability', err);\n  });\n\n  const pasteImageDisposable = vscode.commands.registerCommand(\n    'terminalImgPaste.pasteImage',\n    async () => {\n      try {\n        const toolAvailable = await reader.isToolAvailable();\n        if (!toolAvailable) {\n          vscode.window.showWarningMessage(\n            `Terminal Image Paste: \"${reader.requiredTool()}\" is not installed. ` +\n              `Please install it to paste clipboard images.`,\n          );\n          return;\n        }\n\n        const hasImage = await reader.hasImage();\n        if (!hasImage) {\n          vscode.window.showInformationMessage('No image found in clipboard.');\n          return;\n        }\n\n        const buffer = await reader.readImage();\n        const filePath = await imageStore.save(buffer);\n        insertPathToTerminal(filePath);\n\n        vscode.window.setStatusBarMessage('Image pasted to terminal', 3000);\n      } catch (err) {\n        handleCommandError('pasteImage', err);\n      }\n    },\n  );\n\n  const sendPathDisposable = vscode.commands.registerCommand(\n    'terminalImgPaste.sendPathToTerminal',\n    async (uri: vscode.Uri) => {\n      try {\n        if (!uri?.fsPath) {\n          vscode.window.showErrorMessage(\n            'Terminal Image Paste: No file selected.',\n          );\n          return;\n        }\n\n        insertPathToTerminal(uri.fsPath);\n        vscode.window.setStatusBarMessage('Path sent to terminal', 3000);\n      } catch (err) {\n        handleCommandError('sendPathToTerminal', err);\n      }\n    },\n  );\n\n  context.subscriptions.push(pasteImageDisposable, sendPathDisposable);\n  logger.info(`Extension activated (platform: ${platform.os}, WSL: ${platform.isWSL})`);\n}\n\nexport function deactivate(): void {\n  logger.info('Extension deactivating');\n}\n", "import * as fs from \"fs\";\n\nexport interface PlatformInfo {\n  os: \"macos\" | \"linux\" | \"windows\";\n  isWSL: boolean;\n  displayServer: \"x11\" | \"wayland\" | \"unknown\";\n  powershellPath: string | null;\n}\n\nlet cached: PlatformInfo | null = null;\n\nfunction detectOS(): PlatformInfo[\"os\"] {\n  switch (process.platform) {\n    case \"darwin\":\n      return \"macos\";\n    case \"win32\":\n      return \"windows\";\n    default:\n      return \"linux\";\n  }\n}\n\nfunction detectWSL(): boolean {\n  try {\n    const procVersion = fs.readFileSync(\"/proc/version\", \"utf-8\");\n    return /microsoft/i.test(procVersion);\n  } catch {\n    return false;\n  }\n}\n\nfunction detectDisplayServer(\n  os: PlatformInfo[\"os\"],\n  isWSL: boolean\n): PlatformInfo[\"displayServer\"] {\n  if (os !== \"linux\" || isWSL) {\n    return \"unknown\";\n  }\n\n  const sessionType = process.env.XDG_SESSION_TYPE;\n\n  if (sessionType === \"wayland\") {\n    return \"wayland\";\n  }\n  if (sessionType === \"x11\") {\n    return \"x11\";\n  }\n\n  return \"unknown\";\n}\n\nfunction detectPowershellPath(\n  os: PlatformInfo[\"os\"],\n  isWSL: boolean\n): string | null {\n  if (os === \"windows\") {\n    return \"powershell.exe\";\n  }\n\n  if (isWSL) {\n    const candidates = [\n      \"/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe\",\n      \"/mnt/c/Program Files/PowerShell/7/pwsh.exe\",\n    ];\n\n    for (const candidate of candidates) {\n      if (fs.existsSync(candidate)) {\n        return candidate;\n      }\n    }\n\n    // Fall back to powershell.exe which may be in PATH via interop\n    return \"powershell.exe\";\n  }\n\n  return null;\n}\n\nexport function detectPlatform(): PlatformInfo {\n  if (cached) {\n    return cached;\n  }\n\n  const os = detectOS();\n  const isWSL = os === \"linux\" ? detectWSL() : false;\n  const displayServer = detectDisplayServer(os, isWSL);\n  const powershellPath = detectPowershellPath(os, isWSL);\n\n  cached = { os, isWSL, displayServer, powershellPath };\n  return cached;\n}\n", "import { execFile } from \"child_process\";\n\nconst DEFAULT_TIMEOUT = 10_000;\n\nfunction exitCode(error: Error): string | number {\n  if (\"code\" in error && typeof error.code === \"number\") {\n    return error.code;\n  }\n  return (error as NodeJS.ErrnoException).code ?? \"unknown\";\n}\n\nexport interface ExecResult {\n  stdout: string;\n  stderr: string;\n}\n\nexport interface ExecBufferResult {\n  stdout: Buffer;\n  stderr: string;\n}\n\n/**\n * Execute a command with arguments, returning stdout and stderr as strings.\n * Uses `execFile` (no shell) to avoid shell-injection vulnerabilities.\n */\nexport function exec(\n  command: string,\n  args: string[],\n  options?: { timeout?: number; cwd?: string },\n): Promise<ExecResult> {\n  return new Promise((resolve, reject) => {\n    execFile(\n      command,\n      args,\n      {\n        encoding: \"utf-8\",\n        timeout: options?.timeout ?? DEFAULT_TIMEOUT,\n        cwd: options?.cwd,\n      },\n      (error, stdout, stderr) => {\n        if (error) {\n          reject(\n            new Error(\n              `Command \"${command}\" failed (exit code ${exitCode(error)}): ${stderr || error.message}`,\n            ),\n          );\n          return;\n        }\n        resolve({ stdout, stderr });\n      },\n    );\n  });\n}\n\n/**\n * Execute a command with arguments, returning stdout as a raw Buffer and\n * stderr as a string.  Useful for reading binary data (e.g. clipboard\n * images) from tools that write to stdout.\n *\n * Uses `execFile` (no shell) to avoid shell-injection vulnerabilities.\n */\nexport function execBuffer(\n  command: string,\n  args: string[],\n  options?: { timeout?: number; cwd?: string },\n): Promise<ExecBufferResult> {\n  return new Promise((resolve, reject) => {\n    execFile(\n      command,\n      args,\n      {\n        encoding: \"buffer\",\n        timeout: options?.timeout ?? DEFAULT_TIMEOUT,\n        cwd: options?.cwd,\n      },\n      (error, stdout, stderr) => {\n        // stderr comes back as a Buffer when encoding is \"buffer\"\n        const stderrStr =\n          stderr instanceof Buffer ? stderr.toString(\"utf-8\") : String(stderr);\n        if (error) {\n          reject(\n            new Error(\n              `Command \"${command}\" failed (exit code ${exitCode(error)}): ${stderrStr || error.message}`,\n            ),\n          );\n          return;\n        }\n        resolve({ stdout, stderr: stderrStr });\n      },\n    );\n  });\n}\n", "import { ClipboardReader } from \"./types\";\nimport { exec, execBuffer } from \"../util/exec\";\n\nexport class MacosClipboardReader implements ClipboardReader {\n  requiredTool(): string {\n    return \"pngpaste\";\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    try {\n      await exec(\"which\", [\"pngpaste\"]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async hasImage(): Promise<boolean> {\n    try {\n      const { stdout } = await exec(\"osascript\", [\"-e\", \"clipboard info\"]);\n      return stdout.includes(\"\u00ABclass PNGf\u00BB\") || stdout.includes(\"\u00ABclass TIFF\u00BB\");\n    } catch {\n      return false;\n    }\n  }\n\n  async readImage(): Promise<Buffer> {\n    const imageAvailable = await this.hasImage();\n    if (!imageAvailable) {\n      throw new Error(\"No image found in clipboard\");\n    }\n    const { stdout } = await execBuffer(\"pngpaste\", [\"-\"]);\n    return stdout;\n  }\n}\n", "import { ClipboardReader } from \"./types\";\nimport { PlatformInfo } from \"../platform/detect\";\nimport { exec, execBuffer } from \"../util/exec\";\n\nexport class LinuxClipboardReader implements ClipboardReader {\n  private displayServer: PlatformInfo[\"displayServer\"];\n\n  constructor(displayServer: PlatformInfo[\"displayServer\"]) {\n    this.displayServer = displayServer;\n  }\n\n  private isWayland(): boolean {\n    return this.displayServer === \"wayland\";\n  }\n\n  requiredTool(): string {\n    if (this.isWayland()) {\n      return \"wl-clipboard (wl-paste)\";\n    }\n    return \"xclip\";\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    try {\n      if (this.isWayland()) {\n        await exec(\"which\", [\"wl-paste\"]);\n      } else {\n        await exec(\"which\", [\"xclip\"]);\n      }\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async hasImage(): Promise<boolean> {\n    try {\n      if (this.isWayland()) {\n        const { stdout } = await exec(\"wl-paste\", [\"--list-types\"]);\n        return stdout.includes(\"image/png\");\n      } else {\n        const { stdout } = await exec(\"xclip\", [\n          \"-selection\",\n          \"clipboard\",\n          \"-t\",\n          \"TARGETS\",\n          \"-o\",\n        ]);\n        return stdout.includes(\"image/png\");\n      }\n    } catch {\n      return false;\n    }\n  }\n\n  async readImage(): Promise<Buffer> {\n    const imageAvailable = await this.hasImage();\n    if (!imageAvailable) {\n      throw new Error(\"No image found in clipboard\");\n    }\n\n    if (this.isWayland()) {\n      const { stdout } = await execBuffer(\"wl-paste\", [\n        \"--type\",\n        \"image/png\",\n      ]);\n      return stdout;\n    } else {\n      const { stdout } = await execBuffer(\"xclip\", [\n        \"-selection\",\n        \"clipboard\",\n        \"-t\",\n        \"image/png\",\n        \"-o\",\n      ]);\n      return stdout;\n    }\n  }\n}\n", "import * as fs from \"fs\";\nimport { ClipboardReader } from \"./types\";\nimport { exec } from \"../util/exec\";\n\nconst PS_HAS_IMAGE =\n  \"Add-Type -AssemblyName System.Windows.Forms; if ([System.Windows.Forms.Clipboard]::ContainsImage()) { echo 'yes' } else { echo 'no' }\";\n\nconst PS_READ_IMAGE =\n  \"Add-Type -AssemblyName System.Windows.Forms; $img = [System.Windows.Forms.Clipboard]::GetImage(); if ($img -eq $null) { exit 1 }; $tmp = [System.IO.Path]::GetTempFileName(); $img.Save($tmp, [System.Drawing.Imaging.ImageFormat]::Png); Write-Output $tmp\";\n\n/**\n * Shared base for clipboard readers that use PowerShell to access the\n * Windows clipboard (native Windows and WSL).\n */\nexport abstract class PowerShellClipboardReader implements ClipboardReader {\n  protected abstract get powershellExe(): string;\n\n  abstract requiredTool(): string;\n\n  /** Convert a Windows-style temp path to a path readable by the current OS.\n   *  On native Windows this is an identity operation; on WSL it runs wslpath. */\n  protected abstract resolveTempPath(windowsPath: string): Promise<string>;\n\n  async isToolAvailable(): Promise<boolean> {\n    try {\n      await exec(this.powershellExe, [\"-Command\", \"echo ok\"]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async hasImage(): Promise<boolean> {\n    try {\n      const result = await exec(this.powershellExe, [\n        \"-Command\",\n        PS_HAS_IMAGE,\n      ]);\n      return result.stdout.trim() === \"yes\";\n    } catch {\n      return false;\n    }\n  }\n\n  async readImage(): Promise<Buffer> {\n    const has = await this.hasImage();\n    if (!has) {\n      throw new Error(\"No image found in clipboard\");\n    }\n\n    const result = await exec(this.powershellExe, [\n      \"-Command\",\n      PS_READ_IMAGE,\n    ]);\n\n    const localPath = await this.resolveTempPath(result.stdout.trim());\n    try {\n      return await fs.promises.readFile(localPath);\n    } finally {\n      fs.promises.unlink(localPath).catch(() => {});\n    }\n  }\n}\n", "import { PowerShellClipboardReader } from \"./powershellClipboard\";\n\nexport class WindowsClipboardReader extends PowerShellClipboardReader {\n  protected get powershellExe(): string {\n    return \"powershell.exe\";\n  }\n\n  requiredTool(): string {\n    return \"PowerShell (built-in)\";\n  }\n\n  protected async resolveTempPath(windowsPath: string): Promise<string> {\n    return windowsPath;\n  }\n}\n", "import { PowerShellClipboardReader } from \"./powershellClipboard\";\nimport { PlatformInfo } from \"../platform/detect\";\nimport { exec } from \"../util/exec\";\n\nexport class WslClipboardReader extends PowerShellClipboardReader {\n  private readonly psPath: string;\n\n  constructor(platform: PlatformInfo) {\n    super();\n    this.psPath = platform.powershellPath ?? \"powershell.exe\";\n  }\n\n  protected get powershellExe(): string {\n    return this.psPath;\n  }\n\n  requiredTool(): string {\n    return \"PowerShell (via WSL interop)\";\n  }\n\n  protected async resolveTempPath(windowsPath: string): Promise<string> {\n    const result = await exec(\"wslpath\", [\"-u\", windowsPath]);\n    return result.stdout.trim();\n  }\n}\n", "import { PlatformInfo } from \"../platform/detect\";\nimport { ClipboardReader } from \"./types\";\nimport { MacosClipboardReader } from \"./macosClipboard\";\nimport { LinuxClipboardReader } from \"./linuxClipboard\";\nimport { WindowsClipboardReader } from \"./windowsClipboard\";\nimport { WslClipboardReader } from \"./wslClipboard\";\n\nexport { ClipboardReader } from \"./types\";\n\nexport function createClipboardReader(platform: PlatformInfo): ClipboardReader {\n  if (platform.isWSL) {\n    return new WslClipboardReader(platform);\n  }\n  switch (platform.os) {\n    case \"macos\":\n      return new MacosClipboardReader();\n    case \"windows\":\n      return new WindowsClipboardReader();\n    case \"linux\":\n      return new LinuxClipboardReader(platform.displayServer);\n  }\n}\n", "import * as fs from 'fs';\nimport * as path from 'path';\nimport * as vscode from 'vscode';\nimport { logger } from '../util/logger';\n\nexport interface ImageStore {\n  /** Save a PNG buffer to the image folder. Returns the absolute file path. */\n  save(imageBuffer: Buffer): Promise<string>;\n\n  /** Delete the oldest images if count exceeds maxImages setting. */\n  cleanup(): Promise<void>;\n\n  /** Ensure the image folder is listed in .gitignore (if autoGitIgnore is enabled). */\n  ensureGitIgnored(): Promise<void>;\n}\n\nconst DEFAULT_FOLDER_NAME = '.tip-images';\n\nfunction getConfig(): vscode.WorkspaceConfiguration {\n  return vscode.workspace.getConfiguration('terminalImgPaste');\n}\n\nfunction getWorkspaceRoot(): string {\n  const folders = vscode.workspace.workspaceFolders;\n  if (!folders || folders.length === 0) {\n    vscode.window.showErrorMessage(\n      'Terminal Image Paste: No workspace folder is open. Please open a folder first.',\n    );\n    throw new Error('No workspace folder is open');\n  }\n  return folders[0].uri.fsPath;\n}\n\nfunction getFolderName(): string {\n  return getConfig().get<string>('folderName', DEFAULT_FOLDER_NAME);\n}\n\nfunction getImageFolderPath(): string {\n  return path.join(getWorkspaceRoot(), getFolderName());\n}\n\nfunction generateFileName(): string {\n  const now = new Date();\n  const y = now.getFullYear();\n  const mo = String(now.getMonth() + 1).padStart(2, '0');\n  const d = String(now.getDate()).padStart(2, '0');\n  const h = String(now.getHours()).padStart(2, '0');\n  const mi = String(now.getMinutes()).padStart(2, '0');\n  const s = String(now.getSeconds()).padStart(2, '0');\n  const ms = String(now.getMilliseconds()).padStart(3, '0');\n  return `img-${y}-${mo}-${d}T${h}-${mi}-${s}-${ms}.png`;\n}\n\nexport function createImageStore(): ImageStore {\n  return {\n    async save(imageBuffer: Buffer): Promise<string> {\n      const folder = getImageFolderPath();\n      await fs.promises.mkdir(folder, { recursive: true });\n\n      const fileName = generateFileName();\n      const filePath = path.join(folder, fileName);\n      await fs.promises.writeFile(filePath, imageBuffer);\n\n      logger.info(`Saved image: ${filePath}`);\n\n      await this.cleanup();\n      await this.ensureGitIgnored();\n\n      return filePath;\n    },\n\n    async cleanup(): Promise<void> {\n      const config = getConfig();\n      const maxImages = config.get<number>('maxImages', 20);\n      if (maxImages <= 0) {\n        return;\n      }\n      const folder = getImageFolderPath();\n\n      let entries: string[];\n      try {\n        entries = await fs.promises.readdir(folder);\n      } catch {\n        return;\n      }\n\n      const pngFiles = entries\n        .filter((f) => f.endsWith('.png'))\n        .sort();\n\n      if (pngFiles.length <= maxImages) {\n        return;\n      }\n\n      const toDelete = pngFiles.slice(0, pngFiles.length - maxImages);\n      for (const file of toDelete) {\n        const filePath = path.join(folder, file);\n        await fs.promises.unlink(filePath);\n        logger.info(`Deleted old image: ${filePath}`);\n      }\n    },\n\n    async ensureGitIgnored(): Promise<void> {\n      const config = getConfig();\n      if (!config.get<boolean>('autoGitIgnore', true)) {\n        return;\n      }\n\n      const folderName = getFolderName();\n      const workspaceRoot = getWorkspaceRoot();\n      const gitignorePath = path.join(workspaceRoot, '.gitignore');\n\n      let content: string;\n      try {\n        content = await fs.promises.readFile(gitignorePath, 'utf-8');\n      } catch {\n        await fs.promises.writeFile(gitignorePath, folderName + '\\n', 'utf-8');\n        logger.info(`Created .gitignore with ${folderName}`);\n        return;\n      }\n\n      const lines = content.split('\\n').map((line) => line.trim());\n      if (lines.includes(folderName)) {\n        return;\n      }\n\n      const suffix = content.endsWith('\\n') ? '' : '\\n';\n      await fs.promises.writeFile(\n        gitignorePath,\n        content + suffix + folderName + '\\n',\n        'utf-8',\n      );\n      logger.info(`Added ${folderName} to .gitignore`);\n    },\n  };\n}\n", "import * as vscode from 'vscode';\n\nexport interface Logger {\n  info(message: string): void;\n  warn(message: string): void;\n  error(message: string, err?: unknown): void;\n  show(): void;\n}\n\nfunction timestamp(): string {\n  const now = new Date();\n  const h = String(now.getHours()).padStart(2, '0');\n  const m = String(now.getMinutes()).padStart(2, '0');\n  const s = String(now.getSeconds()).padStart(2, '0');\n  const ms = String(now.getMilliseconds()).padStart(3, '0');\n  return `[${h}:${m}:${s}.${ms}]`;\n}\n\nexport function createLogger(name: string): Logger {\n  const channel = vscode.window.createOutputChannel(name);\n\n  return {\n    info(message: string): void {\n      channel.appendLine(`${timestamp()} [INFO] ${message}`);\n    },\n\n    warn(message: string): void {\n      channel.appendLine(`${timestamp()} [WARN] ${message}`);\n    },\n\n    error(message: string, err?: unknown): void {\n      let line = `${timestamp()} [ERROR] ${message}`;\n      if (err !== undefined) {\n        if (err instanceof Error && err.stack) {\n          line += `\\n${err.stack}`;\n        } else {\n          line += `\\n${String(err)}`;\n        }\n      }\n      channel.appendLine(line);\n    },\n\n    show(): void {\n      channel.show();\n    },\n  };\n}\n\nexport const logger: Logger = createLogger('Terminal Image Paste');\n", "import * as vscode from 'vscode';\nimport { logger } from '../util/logger';\n\n/**\n * Send a file path to the active terminal.\n * Single-quotes the path to prevent shell expansion of special characters.\n * Reads `sendNewline` setting to decide whether to append a newline.\n */\nexport function insertPathToTerminal(filePath: string): void {\n  const terminal = vscode.window.activeTerminal;\n  if (!terminal) {\n    vscode.window.showErrorMessage(\n      'Terminal Image Paste: No active terminal. Please open a terminal first.',\n    );\n    return;\n  }\n\n  // Single-quote the path, escaping any embedded single quotes\n  const text = \"'\" + filePath.replace(/'/g, \"'\\\\''\") + \"'\";\n\n  const config = vscode.workspace.getConfiguration('terminalImgPaste');\n  const addNewline = config.get<boolean>('sendNewline', false);\n\n  terminal.sendText(text, addNewline);\n  logger.info(`Inserted path into terminal: ${text}`);\n}\n"],
  "mappings": "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",
  "names": ["extension_exports", "__export", "activate", "deactivate", "__toCommonJS", "vscode", "fs", "cached", "detectOS", "detectWSL", "procVersion", "detectDisplayServer", "os", "isWSL", "sessionType", "detectPowershellPath", "candidates", "candidate", "detectPlatform", "displayServer", "powershellPath", "import_child_process", "DEFAULT_TIMEOUT", "exitCode", "error", "exec", "command", "args", "options", "resolve", "reject", "stdout", "stderr", "execBuffer", "stderrStr", "MacosClipboardReader", "exec", "stdout", "execBuffer", "LinuxClipboardReader", "displayServer", "exec", "stdout", "execBuffer", "fs", "PS_HAS_IMAGE", "PS_READ_IMAGE", "PowerShellClipboardReader", "exec", "result", "localPath", "WindowsClipboardReader", "PowerShellClipboardReader", "windowsPath", "WslClipboardReader", "PowerShellClipboardReader", "platform", "windowsPath", "exec", "createClipboardReader", "platform", "WslClipboardReader", "MacosClipboardReader", "WindowsClipboardReader", "LinuxClipboardReader", "fs", "path", "vscode", "vscode", "timestamp", "now", "h", "m", "s", "ms", "createLogger", "name", "channel", "message", "err", "line", "logger", "DEFAULT_FOLDER_NAME", "getConfig", "getWorkspaceRoot", "folders", "getFolderName", "getImageFolderPath", "generateFileName", "now", "y", "mo", "d", "h", "mi", "ms", "createImageStore", "imageBuffer", "folder", "fileName", "filePath", "logger", "maxImages", "entries", "pngFiles", "f", "toDelete", "file", "folderName", "workspaceRoot", "gitignorePath", "content", "line", "suffix", "vscode", "insertPathToTerminal", "filePath", "terminal", "text", "addNewline", "logger", "handleCommandError", "commandName", "err", "message", "logger", "activate", "context", "platform", "detectPlatform", "reader", "createClipboardReader", "imageStore", "createImageStore", "available", "pasteImageDisposable", "buffer", "filePath", "insertPathToTerminal", "sendPathDisposable", "uri", "deactivate"]
}
