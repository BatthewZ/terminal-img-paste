{
  "version": 3,
  "sources": ["../src/extension.ts", "../src/platform/detect.ts", "../src/platform/remote.ts", "../src/util/exec.ts", "../src/util/toolPath.ts", "../src/util/logger.ts", "../src/clipboard/macosClipboard.ts", "../src/clipboard/macosOsascriptClipboard.ts", "../src/clipboard/linuxClipboard.ts", "../src/clipboard/powershellClipboard.ts", "../src/util/powershell.ts", "../src/clipboard/windowsClipboard.ts", "../src/clipboard/wslClipboard.ts", "../src/clipboard/fallback.ts", "../src/clipboard/filePathClipboard.ts", "../src/clipboard/index.ts", "../src/storage/imageStore.ts", "../src/util/fs.ts", "../src/terminal/insertPath.ts", "../src/terminal/shellDetect.ts", "../src/image/convert.ts", "../src/views/previewPanel.ts", "../src/views/dropZoneProvider.ts", "../src/util/notify.ts", "../src/util/mutex.ts", "../src/commands/diagnostics.ts", "../src/api.ts"],
  "sourcesContent": ["import * as vscode from 'vscode';\nimport { detectPlatform } from './platform/detect';\nimport { detectRemoteContext } from './platform/remote';\nimport { createClipboardReader, ClipboardReader } from './clipboard/index';\nimport { createImageStore, ImageStore } from './storage/imageStore';\nimport { insertPathToTerminal } from './terminal/insertPath';\nimport { convertImage, SaveFormat } from './image/convert';\nimport { showImagePreview } from './views/previewPanel';\nimport { DropZoneProvider } from './views/dropZoneProvider';\nimport { logger } from './util/logger';\nimport { notify } from './util/notify';\nimport { Mutex } from './util/mutex';\nimport { runDiagnostics } from './commands/diagnostics';\nimport { createApi, type PasteResult, type TerminalImgPasteApi } from './api';\n\nfunction handleCommandError(commandName: string, err: unknown): void {\n  const message = err instanceof Error ? err.message : String(err);\n  notify.error(`Terminal Image Paste: ${message}`);\n  logger.error(`${commandName} command failed`, err);\n}\n\nexport function activate(context: vscode.ExtensionContext): TerminalImgPasteApi {\n  const platform = detectPlatform();\n  const reader: ClipboardReader = createClipboardReader(platform);\n  const imageStore: ImageStore = createImageStore();\n  const pasteEmitter = new vscode.EventEmitter<PasteResult>();\n  context.subscriptions.push(pasteEmitter);\n\n  // Check tool availability at activation \u2014 warn but don't block\n  reader.isToolAvailable().then((available) => {\n    if (!available) {\n      void notify.warning(\n        `Terminal Image Paste: clipboard tool \"${reader.requiredTool()}\" not found. ` +\n          `Install it to use clipboard image pasting.`,\n      );\n    }\n  }).catch((err) => {\n    logger.error('Failed to check tool availability', err);\n  });\n\n  const pasteMutex = new Mutex();\n\n  const pasteImageDisposable = vscode.commands.registerCommand(\n    'terminalImgPaste.pasteImage',\n    async () => {\n      const release = await pasteMutex.acquire();\n      try {\n        const toolAvailable = await reader.isToolAvailable();\n        if (!toolAvailable) {\n          void notify.warning(\n            `Terminal Image Paste: \"${reader.requiredTool()}\" is not installed. ` +\n              `Please install it to paste clipboard images.`,\n          );\n          return;\n        }\n\n        const config = vscode.workspace.getConfiguration('terminalImgPaste');\n        const warnOnRemote = config.get<boolean>('warnOnRemote', true);\n\n        if (warnOnRemote) {\n          const remoteCtx = detectRemoteContext();\n          if (remoteCtx.remote && remoteCtx.type !== 'wsl') {\n            const choice = await notify.warning(\n              'Clipboard images are saved locally. The pasted path may not be accessible from the remote terminal.',\n              'Paste Anyway',\n              'Cancel',\n            );\n            if (choice !== 'Paste Anyway') {\n              return;\n            }\n          }\n        }\n\n        const hasImage = await reader.hasImage();\n        if (!hasImage) {\n          notify.info('No image found in clipboard.');\n          return;\n        }\n\n        const { data, format } = await reader.readImage();\n\n        const showPreview = config.get<boolean>('showPreview', false);\n        if (showPreview) {\n          const confirmed = await showImagePreview(data, format);\n          if (!confirmed) {\n            notify.statusBar('Image paste cancelled', 3000);\n            return;\n          }\n        }\n\n        const saveFormat = config.get<SaveFormat>('saveFormat', 'auto');\n        const converted = await convertImage(data, format, saveFormat, platform);\n\n        const filePath = await imageStore.save(converted.data, converted.format);\n        insertPathToTerminal(filePath);\n\n        pasteEmitter.fire({ path: filePath, format: converted.format });\n        notify.statusBar('Image pasted to terminal', 3000);\n      } catch (err) {\n        handleCommandError('pasteImage', err);\n      } finally {\n        release();\n      }\n    },\n  );\n\n  const sendPathDisposable = vscode.commands.registerCommand(\n    'terminalImgPaste.sendPathToTerminal',\n    async (uri: vscode.Uri) => {\n      try {\n        if (!uri?.fsPath) {\n          notify.error('Terminal Image Paste: No file selected.');\n          return;\n        }\n\n        insertPathToTerminal(uri.fsPath);\n        notify.statusBar('Path sent to terminal', 3000);\n      } catch (err) {\n        handleCommandError('sendPathToTerminal', err);\n      }\n    },\n  );\n\n  const diagnosticsDisposable = vscode.commands.registerCommand(\n    'terminalImgPaste.showDiagnostics',\n    () => runDiagnostics(platform, reader),\n  );\n\n  for (const viewId of ['terminalImgPaste.dropZone', 'terminalImgPaste.panelDropZone']) {\n    const provider = new DropZoneProvider(context.extensionUri, imageStore, pasteEmitter, pasteMutex);\n    context.subscriptions.push(\n      vscode.window.registerWebviewViewProvider(viewId, provider),\n    );\n  }\n\n  context.subscriptions.push(pasteImageDisposable, sendPathDisposable, diagnosticsDisposable);\n  logger.info(`Extension activated (platform: ${platform.os}, WSL: ${platform.isWSL})`);\n\n  return createApi(platform, reader, imageStore, pasteEmitter);\n}\n\nexport function deactivate(): void {\n  logger.info('Extension deactivating');\n}\n", "import * as fs from \"fs\";\nimport { execFileSync } from \"child_process\";\n\nexport interface PlatformInfo {\n  os: \"macos\" | \"linux\" | \"windows\";\n  isWSL: boolean;\n  wslVersion: 1 | 2 | null;\n  hasWslg: boolean;\n  displayServer: \"x11\" | \"wayland\" | \"unknown\";\n  powershellPath: string | null;\n}\n\nlet cached: PlatformInfo | null = null;\n\nfunction detectOS(): PlatformInfo[\"os\"] {\n  switch (process.platform) {\n    case \"darwin\":\n      return \"macos\";\n    case \"win32\":\n      return \"windows\";\n    default:\n      return \"linux\";\n  }\n}\n\nfunction readProcVersion(): string | null {\n  try {\n    return fs.readFileSync(\"/proc/version\", \"utf-8\");\n  } catch {\n    return null;\n  }\n}\n\nfunction detectWSL(procVersion: string | null): boolean {\n  if (!procVersion) {\n    return false;\n  }\n  return /microsoft/i.test(procVersion);\n}\n\nfunction detectWslVersion(procVersion: string | null): 1 | 2 | null {\n  if (!procVersion || !detectWSL(procVersion)) {\n    return null;\n  }\n  // WSL2 kernels contain \"microsoft-standard-WSL2\"\n  if (/microsoft-standard-WSL2/i.test(procVersion)) {\n    return 2;\n  }\n  // WSL1 kernels contain \"Microsoft\" but not \"microsoft-standard-WSL2\"\n  return 1;\n}\n\nfunction detectWslg(): boolean {\n  return fs.existsSync(\"/mnt/wslg/\");\n}\n\nfunction detectDisplayServer(\n  os: PlatformInfo[\"os\"],\n  isWSL: boolean\n): PlatformInfo[\"displayServer\"] {\n  if (os !== \"linux\") {\n    return \"unknown\";\n  }\n\n  // For WSL, check for WSLg (which provides X11/Wayland via /mnt/wslg/)\n  if (isWSL) {\n    if (process.env.WAYLAND_DISPLAY) {\n      return \"wayland\";\n    }\n    if (process.env.DISPLAY) {\n      return \"x11\";\n    }\n    return \"unknown\";\n  }\n\n  const sessionType = process.env.XDG_SESSION_TYPE;\n\n  if (sessionType === \"wayland\") {\n    return \"wayland\";\n  }\n  if (sessionType === \"x11\") {\n    return \"x11\";\n  }\n\n  // Fallback: WAYLAND_DISPLAY is set by Wayland compositors even when\n  // XDG_SESSION_TYPE is absent (containers, some desktop environments, etc.)\n  if (process.env.WAYLAND_DISPLAY) {\n    return \"wayland\";\n  }\n\n  return \"unknown\";\n}\n\nfunction whichSync(name: string): string | null {\n  try {\n    return execFileSync(\"command\", [\"-v\", name], {\n      encoding: \"utf-8\",\n      timeout: 5000,\n      shell: true,\n    }).trim() || null;\n  } catch {\n    return null;\n  }\n}\n\nfunction detectPowershellPath(\n  os: PlatformInfo[\"os\"],\n  isWSL: boolean\n): string | null {\n  if (os === \"windows\") {\n    return \"powershell.exe\";\n  }\n\n  if (isWSL) {\n    // 1. Check well-known filesystem paths (fast, no subprocess)\n    const candidates = [\n      \"/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe\",\n      \"/mnt/c/Program Files/PowerShell/7/pwsh.exe\",\n    ];\n\n    for (const candidate of candidates) {\n      if (fs.existsSync(candidate)) {\n        return candidate;\n      }\n    }\n\n    // 2. Try PATH-based discovery (handles non-standard mount points)\n    const fromPath =\n      whichSync(\"powershell.exe\") ?? whichSync(\"pwsh.exe\");\n    if (fromPath) {\n      return fromPath;\n    }\n\n    // 3. Last resort: rely on WSL interop PATH\n    return \"powershell.exe\";\n  }\n\n  return null;\n}\n\nexport function detectPlatform(): PlatformInfo {\n  if (cached) {\n    return cached;\n  }\n\n  const os = detectOS();\n  const procVersion = os === \"linux\" ? readProcVersion() : null;\n  const isWSL = os === \"linux\" ? detectWSL(procVersion) : false;\n  const wslVersion = isWSL ? detectWslVersion(procVersion) : null;\n  const hasWslg = isWSL ? detectWslg() : false;\n  const displayServer = detectDisplayServer(os, isWSL);\n  const powershellPath = detectPowershellPath(os, isWSL);\n\n  cached = { os, isWSL, wslVersion, hasWslg, displayServer, powershellPath };\n  return cached;\n}\n", "import * as vscode from 'vscode';\n\nexport type RemoteContext =\n  | { remote: false }\n  | { remote: true; type: 'ssh-remote' | 'dev-container' | 'wsl' | 'tunnel' | 'codespaces' | string };\n\nexport function detectRemoteContext(): RemoteContext {\n  const remoteName = vscode.env.remoteName;\n\n  if (!remoteName) {\n    return { remote: false };\n  }\n\n  return { remote: true, type: remoteName };\n}\n", "import { execFile, spawn } from \"child_process\";\n\nconst DEFAULT_TIMEOUT = 10_000;\nconst DEFAULT_MAX_BUFFER = 10 * 1024 * 1024; // 10 MB\nconst DEFAULT_MAX_BUFFER_BINARY = 50 * 1024 * 1024; // 50 MB\n\nfunction exitCode(error: Error): string | number {\n  if (\"code\" in error && typeof error.code === \"number\") {\n    return error.code;\n  }\n  return (error as NodeJS.ErrnoException).code ?? \"unknown\";\n}\n\nexport interface ExecOptions {\n  timeout?: number;\n  cwd?: string;\n  maxBuffer?: number;\n  input?: Buffer;\n}\n\nexport interface ExecResult {\n  stdout: string;\n  stderr: string;\n}\n\nexport interface ExecBufferResult {\n  stdout: Buffer;\n  stderr: string;\n}\n\n/**\n * Execute a command with arguments, returning stdout and stderr as strings.\n * Uses `execFile` (no shell) to avoid shell-injection vulnerabilities.\n */\nexport function exec(\n  command: string,\n  args: string[],\n  options?: ExecOptions,\n): Promise<ExecResult> {\n  return new Promise((resolve, reject) => {\n    execFile(\n      command,\n      args,\n      {\n        encoding: \"utf-8\",\n        timeout: options?.timeout ?? DEFAULT_TIMEOUT,\n        maxBuffer: options?.maxBuffer ?? DEFAULT_MAX_BUFFER,\n        cwd: options?.cwd,\n      },\n      (error, stdout, stderr) => {\n        if (error) {\n          reject(\n            new Error(\n              `Command \"${command}\" failed (exit code ${exitCode(error)}): ${stderr || error.message}`,\n            ),\n          );\n          return;\n        }\n        resolve({ stdout, stderr });\n      },\n    );\n  });\n}\n\n/**\n * Execute a command with arguments, returning stdout as a raw Buffer and\n * stderr as a string.  Useful for reading binary data (e.g. clipboard\n * images) from tools that write to stdout.\n *\n * Uses `execFile` (no shell) to avoid shell-injection vulnerabilities.\n * When `options.input` is provided, uses `spawn` to pipe data to stdin.\n */\nexport function execBuffer(\n  command: string,\n  args: string[],\n  options?: ExecOptions,\n): Promise<ExecBufferResult> {\n  if (options?.input) {\n    return execBufferWithStdin(command, args, options as ExecOptions & { input: Buffer });\n  }\n\n  return new Promise((resolve, reject) => {\n    execFile(\n      command,\n      args,\n      {\n        encoding: \"buffer\",\n        timeout: options?.timeout ?? DEFAULT_TIMEOUT,\n        maxBuffer: options?.maxBuffer ?? DEFAULT_MAX_BUFFER_BINARY,\n        cwd: options?.cwd,\n      },\n      (error, stdout, stderr) => {\n        // stderr comes back as a Buffer when encoding is \"buffer\"\n        const stderrStr =\n          stderr instanceof Buffer ? stderr.toString(\"utf-8\") : String(stderr);\n        if (error) {\n          reject(\n            new Error(\n              `Command \"${command}\" failed (exit code ${exitCode(error)}): ${stderrStr || error.message}`,\n            ),\n          );\n          return;\n        }\n        resolve({ stdout, stderr: stderrStr });\n      },\n    );\n  });\n}\n\n/**\n * Internal helper: execute a command with stdin data piped to it.\n * Uses `spawn` (no shell) to pipe input data to the child process's stdin.\n */\nfunction execBufferWithStdin(\n  command: string,\n  args: string[],\n  options: ExecOptions & { input: Buffer },\n): Promise<ExecBufferResult> {\n  const timeout = options.timeout ?? DEFAULT_TIMEOUT;\n  const maxBuffer = options.maxBuffer ?? DEFAULT_MAX_BUFFER_BINARY;\n\n  return new Promise((resolve, reject) => {\n    const child = spawn(command, args, {\n      stdio: [\"pipe\", \"pipe\", \"pipe\"],\n      cwd: options.cwd,\n    });\n\n    const stdoutChunks: Buffer[] = [];\n    const stderrChunks: Buffer[] = [];\n    let stdoutLen = 0;\n    let stderrLen = 0;\n    let finished = false;\n\n    const timer = setTimeout(() => {\n      if (!finished) {\n        finished = true;\n        child.kill(\"SIGTERM\");\n        reject(\n          new Error(\n            `Command \"${command}\" failed (exit code ETIMEDOUT): timed out after ${timeout}ms`,\n          ),\n        );\n      }\n    }, timeout);\n\n    child.stdout!.on(\"data\", (chunk: Buffer) => {\n      stdoutLen += chunk.length;\n      if (stdoutLen > maxBuffer) {\n        if (!finished) {\n          finished = true;\n          clearTimeout(timer);\n          child.kill(\"SIGTERM\");\n          reject(\n            new Error(\n              `Command \"${command}\" failed (exit code ERR_CHILD_PROCESS_STDIO_MAXBUFFER): stdout maxBuffer length exceeded`,\n            ),\n          );\n        }\n        return;\n      }\n      stdoutChunks.push(chunk);\n    });\n\n    child.stderr!.on(\"data\", (chunk: Buffer) => {\n      stderrLen += chunk.length;\n      if (stderrLen <= maxBuffer) {\n        stderrChunks.push(chunk);\n      }\n    });\n\n    child.on(\"error\", (err: Error) => {\n      if (!finished) {\n        finished = true;\n        clearTimeout(timer);\n        reject(\n          new Error(\n            `Command \"${command}\" failed (exit code ${exitCode(err)}): ${err.message}`,\n          ),\n        );\n      }\n    });\n\n    child.on(\"close\", (code: number | null) => {\n      if (finished) {\n        return;\n      }\n      finished = true;\n      clearTimeout(timer);\n\n      const stderrStr = Buffer.concat(stderrChunks).toString(\"utf-8\");\n      if (code !== 0) {\n        reject(\n          new Error(\n            `Command \"${command}\" failed (exit code ${code ?? \"unknown\"}): ${stderrStr || `process exited with code ${code}`}`,\n          ),\n        );\n        return;\n      }\n      resolve({\n        stdout: Buffer.concat(stdoutChunks),\n        stderr: stderrStr,\n      });\n    });\n\n    // Ignore EPIPE errors on stdin (child may exit before consuming all input)\n    child.stdin!.on(\"error\", () => {});\n    // Write input to stdin and close it\n    child.stdin!.end(options.input);\n  });\n}\n", "import { execFile } from 'child_process';\nimport { logger } from './logger';\n\nconst cache = new Map<string, string>();\n\nconst isWindows = process.platform === 'win32';\n\n/**\n * Resolves a tool name to its absolute path using `which` (Unix) or `where` (Windows).\n * Caches the result for subsequent calls.\n * Returns undefined if the tool is not found.\n */\nexport async function resolveToolPath(toolName: string): Promise<string | undefined> {\n  const cached = cache.get(toolName);\n  if (cached !== undefined) {\n    return cached;\n  }\n\n  const resolver = isWindows ? 'where' : 'which';\n  try {\n    const resolved = await new Promise<string>((resolve, reject) => {\n      execFile(resolver, [toolName], { timeout: 5000 }, (error, stdout) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        // `where` on Windows may return multiple lines; take the first\n        const firstLine = stdout.trim().split(/\\r?\\n/)[0];\n        resolve(firstLine);\n      });\n    });\n    cache.set(toolName, resolved);\n    return resolved;\n  } catch {\n    logger.warn(`Could not resolve absolute path for \"${toolName}\" \u2014 using bare name`);\n    return undefined;\n  }\n}\n\n/**\n * Resolve a tool name, returning the absolute path if found or the original name as fallback.\n */\nexport async function resolveToolPathOrFallback(toolName: string): Promise<string> {\n  return (await resolveToolPath(toolName)) ?? toolName;\n}\n\n/** Clear the resolved tool path cache (useful for testing). */\nexport function clearToolPathCache(): void {\n  cache.clear();\n}\n", "import * as vscode from 'vscode';\n\nexport interface Logger {\n  info(message: string): void;\n  warn(message: string, err?: unknown): void;\n  error(message: string, err?: unknown): void;\n  show(): void;\n}\n\nfunction timestamp(): string {\n  const now = new Date();\n  const h = String(now.getHours()).padStart(2, '0');\n  const m = String(now.getMinutes()).padStart(2, '0');\n  const s = String(now.getSeconds()).padStart(2, '0');\n  const ms = String(now.getMilliseconds()).padStart(3, '0');\n  return `[${h}:${m}:${s}.${ms}]`;\n}\n\nexport function createLogger(name: string): Logger {\n  const channel = vscode.window.createOutputChannel(name);\n\n  return {\n    info(message: string): void {\n      channel.appendLine(`${timestamp()} [INFO] ${message}`);\n    },\n\n    warn(message: string, err?: unknown): void {\n      let line = `${timestamp()} [WARN] ${message}`;\n      if (err !== undefined) {\n        if (err instanceof Error && err.stack) {\n          line += `\\n${err.stack}`;\n        } else {\n          line += `\\n${String(err)}`;\n        }\n      }\n      channel.appendLine(line);\n    },\n\n    error(message: string, err?: unknown): void {\n      let line = `${timestamp()} [ERROR] ${message}`;\n      if (err !== undefined) {\n        if (err instanceof Error && err.stack) {\n          line += `\\n${err.stack}`;\n        } else {\n          line += `\\n${String(err)}`;\n        }\n      }\n      channel.appendLine(line);\n    },\n\n    show(): void {\n      channel.show();\n    },\n  };\n}\n\nexport const logger: Logger = createLogger('Terminal Image Paste');\n", "import { ClipboardReader, ClipboardFormat, ClipboardImageResult } from \"./types\";\nimport { exec, execBuffer } from \"../util/exec\";\nimport { resolveToolPathOrFallback } from \"../util/toolPath\";\n\n/** Fetch raw clipboard info string from osascript (shared by macOS readers). */\nexport async function getClipboardInfo(): Promise<string> {\n  const { stdout } = await exec(\"osascript\", [\"-e\", \"clipboard info\"]);\n  return stdout;\n}\n\n/** Parse macOS `clipboard info` output and return detected formats in preference order. */\nexport function parseClipboardFormats(info: string): ClipboardFormat[] {\n  const formats: ClipboardFormat[] = [];\n  if (info.includes(\"\u00ABclass PNGf\u00BB\")) {\n    formats.push(\"png\");\n  }\n  if (info.includes(\"\u00ABclass JPEG\u00BB\") || info.includes(\"\u00ABclass JPEf\u00BB\")) {\n    formats.push(\"jpeg\");\n  }\n  if (info.includes(\"\u00ABclass TIFF\u00BB\")) {\n    formats.push(\"tiff\");\n  }\n  if (info.includes(\"\u00ABclass BMP \u00BB\") || info.includes(\"\u00ABclass BMPf\u00BB\")) {\n    formats.push(\"bmp\");\n  }\n  return formats;\n}\n\nexport class MacosClipboardReader implements ClipboardReader {\n  private resolvedPngpastePath: string | undefined;\n\n  private async getPngpastePath(): Promise<string> {\n    if (this.resolvedPngpastePath === undefined) {\n      this.resolvedPngpastePath = await resolveToolPathOrFallback(\"pngpaste\");\n    }\n    return this.resolvedPngpastePath;\n  }\n\n  requiredTool(): string {\n    return \"pngpaste\";\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    try {\n      await exec(\"which\", [\"pngpaste\"]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async hasImage(): Promise<boolean> {\n    try {\n      const info = await getClipboardInfo();\n      return parseClipboardFormats(info).length > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  async detectFormat(): Promise<ClipboardFormat> {\n    const info = await getClipboardInfo();\n    const formats = parseClipboardFormats(info);\n    if (formats.length > 0) {\n      return formats[0];\n    }\n    throw new Error(\"No image found in clipboard\");\n  }\n\n  async readImage(): Promise<ClipboardImageResult> {\n    const imageAvailable = await this.hasImage();\n    if (!imageAvailable) {\n      throw new Error(\"No image found in clipboard\");\n    }\n    const pngpaste = await this.getPngpastePath();\n    const { stdout } = await execBuffer(pngpaste, [\"-\"]);\n    return { data: stdout, format: \"png\" };\n  }\n}\n", "import { ClipboardReader, ClipboardFormat, ClipboardImageResult } from \"./types\";\nimport { execBuffer } from \"../util/exec\";\nimport { getClipboardInfo, parseClipboardFormats } from \"./macosClipboard\";\n\n/** Map from ClipboardFormat to the osascript class name used for clipboard coercion. */\nconst FORMAT_TO_OSASCRIPT_CLASS: Record<string, string> = {\n  png: \"PNGf\",\n  jpeg: \"JPEG\",\n  tiff: \"TIFF\",\n};\n\n/**\n * macOS clipboard reader using only osascript.\n * Used as a fallback when pngpaste is not installed.\n */\nexport class MacosOsascriptClipboardReader implements ClipboardReader {\n  requiredTool(): string {\n    return \"osascript (built-in)\";\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    return process.platform === \"darwin\";\n  }\n\n  async hasImage(): Promise<boolean> {\n    try {\n      const info = await getClipboardInfo();\n      return parseClipboardFormats(info).length > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  async detectFormat(): Promise<ClipboardFormat> {\n    const info = await getClipboardInfo();\n    const formats = parseClipboardFormats(info);\n    if (formats.length > 0) {\n      return formats[0];\n    }\n    throw new Error(\"No image found in clipboard\");\n  }\n\n  async readImage(): Promise<ClipboardImageResult> {\n    const format = await this.detectFormat();\n    const hasNativeClass = format in FORMAT_TO_OSASCRIPT_CLASS;\n    const osClass = hasNativeClass ? FORMAT_TO_OSASCRIPT_CLASS[format] : \"PNGf\";\n    const resolvedFormat = hasNativeClass ? format : \"png\";\n\n    const { stdout } = await execBuffer(\"osascript\", [\n      \"-e\",\n      `set imgData to (the clipboard as \u00ABclass ${osClass}\u00BB)`,\n      \"-e\",\n      \"return imgData\",\n    ]);\n    return { data: stdout, format: resolvedFormat };\n  }\n}\n", "import { ClipboardReader, ClipboardFormat, ClipboardImageResult } from \"./types\";\nimport { PlatformInfo } from \"../platform/detect\";\nimport { exec, execBuffer } from \"../util/exec\";\nimport { resolveToolPathOrFallback } from \"../util/toolPath\";\n\n/** MIME type to ClipboardFormat mapping, in preference order. */\nconst MIME_FORMAT_MAP: Array<[string, ClipboardFormat]> = [\n  [\"image/png\", \"png\"],\n  [\"image/jpeg\", \"jpeg\"],\n  [\"image/webp\", \"webp\"],\n  [\"image/tiff\", \"tiff\"],\n  [\"image/bmp\", \"bmp\"],\n  [\"image/x-bmp\", \"bmp\"],\n];\n\n/** Parse a list of MIME types and return the best matching ClipboardFormat. */\nfunction detectFormatFromMimeTypes(\n  mimeList: string,\n): ClipboardFormat | null {\n  for (const [mime, format] of MIME_FORMAT_MAP) {\n    if (mimeList.includes(mime)) {\n      return format;\n    }\n  }\n  // Check for any unrecognized image/* type\n  if (/^image\\//m.test(mimeList)) {\n    return \"unknown\";\n  }\n  return null;\n}\n\n/** Find the best MIME type and its format from a clipboard type list. */\nfunction detectMimeAndFormat(\n  mimeList: string,\n): { mime: string; format: ClipboardFormat } | null {\n  for (const [mime, format] of MIME_FORMAT_MAP) {\n    if (mimeList.includes(mime)) {\n      return { mime, format };\n    }\n  }\n  if (/^image\\//m.test(mimeList)) {\n    return { mime: \"image/png\", format: \"unknown\" };\n  }\n  return null;\n}\n\nexport class LinuxClipboardReader implements ClipboardReader {\n  private displayServer: PlatformInfo[\"displayServer\"];\n  private resolvedToolPath: string | undefined;\n\n  constructor(displayServer: PlatformInfo[\"displayServer\"]) {\n    this.displayServer = displayServer;\n  }\n\n  private isWayland(): boolean {\n    return this.displayServer === \"wayland\";\n  }\n\n  private toolName(): string {\n    return this.isWayland() ? \"wl-paste\" : \"xclip\";\n  }\n\n  private async getToolPath(): Promise<string> {\n    if (this.resolvedToolPath === undefined) {\n      this.resolvedToolPath = await resolveToolPathOrFallback(this.toolName());\n    }\n    return this.resolvedToolPath;\n  }\n\n  requiredTool(): string {\n    if (this.isWayland()) {\n      return \"wl-clipboard (wl-paste)\";\n    }\n    return \"xclip\";\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    try {\n      if (this.isWayland()) {\n        await exec(\"which\", [\"wl-paste\"]);\n      } else {\n        await exec(\"which\", [\"xclip\"]);\n      }\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /** Get the list of available clipboard types/targets. */\n  private async getClipboardTypes(): Promise<string> {\n    const tool = await this.getToolPath();\n    if (this.isWayland()) {\n      const { stdout } = await exec(tool, [\"--list-types\"]);\n      return stdout;\n    } else {\n      const { stdout } = await exec(tool, [\n        \"-selection\",\n        \"clipboard\",\n        \"-t\",\n        \"TARGETS\",\n        \"-o\",\n      ]);\n      return stdout;\n    }\n  }\n\n  async hasImage(): Promise<boolean> {\n    try {\n      const types = await this.getClipboardTypes();\n      return /^image\\//m.test(types);\n    } catch {\n      return false;\n    }\n  }\n\n  async detectFormat(): Promise<ClipboardFormat> {\n    const types = await this.getClipboardTypes();\n    const format = detectFormatFromMimeTypes(types);\n    if (format !== null) {\n      return format;\n    }\n    throw new Error(\"No image found in clipboard\");\n  }\n\n  async readImage(): Promise<ClipboardImageResult> {\n    const types = await this.getClipboardTypes();\n    const detected = detectMimeAndFormat(types);\n    if (!detected) {\n      throw new Error(\"No image found in clipboard\");\n    }\n    const { mime, format } = detected;\n    const resolvedFormat = format === \"unknown\" ? \"png\" : format;\n\n    const tool = await this.getToolPath();\n    const { stdout } = this.isWayland()\n      ? await execBuffer(tool, [\"--type\", mime])\n      : await execBuffer(tool, [\n          \"-selection\",\n          \"clipboard\",\n          \"-t\",\n          mime,\n          \"-o\",\n        ]);\n    return { data: stdout, format: resolvedFormat };\n  }\n}\n", "import * as fs from \"fs\";\nimport { ClipboardReader, ClipboardFormat, ClipboardImageResult } from \"./types\";\nimport { exec } from \"../util/exec\";\nimport { encodePowerShellCommand } from \"../util/powershell\";\nimport { logger } from \"../util/logger\";\n\nconst PS_HAS_IMAGE =\n  \"Add-Type -AssemblyName System.Windows.Forms; if ([System.Windows.Forms.Clipboard]::ContainsImage()) { echo 'yes' } else { echo 'no' }\";\n\n/** PowerShell script that saves the clipboard image to a temp file and outputs its path. */\nconst PS_READ_IMAGE =\n  \"Add-Type -AssemblyName System.Windows.Forms; $img = [System.Windows.Forms.Clipboard]::GetImage(); if ($img -eq $null) { exit 1 }; $tmp = [System.IO.Path]::GetTempFileName(); $img.Save($tmp, [System.Drawing.Imaging.ImageFormat]::Png); Write-Output $tmp\";\n\n/**\n * Shared base for clipboard readers that use PowerShell to access the\n * Windows clipboard (native Windows and WSL).\n */\nexport abstract class PowerShellClipboardReader implements ClipboardReader {\n  protected abstract get powershellExe(): string;\n\n  abstract requiredTool(): string;\n\n  /** Convert a Windows-style temp path to a path readable by the current OS.\n   *  On native Windows this is an identity operation; on WSL it runs wslpath. */\n  protected abstract resolveTempPath(windowsPath: string): Promise<string>;\n\n  async isToolAvailable(): Promise<boolean> {\n    try {\n      await exec(this.powershellExe, [\"-Command\", \"echo ok\"]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async hasImage(): Promise<boolean> {\n    try {\n      const result = await exec(this.powershellExe, [\n        \"-EncodedCommand\",\n        encodePowerShellCommand(PS_HAS_IMAGE),\n      ]);\n      return result.stdout.trim() === \"yes\";\n    } catch {\n      return false;\n    }\n  }\n\n  async detectFormat(): Promise<ClipboardFormat> {\n    const has = await this.hasImage();\n    if (!has) {\n      throw new Error(\"No image found in clipboard\");\n    }\n    // PowerShell's System.Drawing always re-encodes to PNG\n    return \"png\";\n  }\n\n  async readImage(): Promise<ClipboardImageResult> {\n    let tempPath: string;\n    try {\n      const result = await exec(this.powershellExe, [\n        \"-EncodedCommand\",\n        encodePowerShellCommand(PS_READ_IMAGE),\n      ]);\n      tempPath = result.stdout.trim();\n    } catch (err) {\n      throw new Error(\n        `PowerShell execution failed: ${err instanceof Error ? err.message : err}`,\n      );\n    }\n\n    const localPath = await this.resolveTempPath(tempPath);\n    try {\n      const data = await fs.promises.readFile(localPath);\n      return { data, format: \"png\" };\n    } catch (err) {\n      throw new Error(\n        `Temp file read failed: could not read \"${localPath}\": ${err instanceof Error ? err.message : err}`,\n      );\n    } finally {\n      fs.promises.unlink(localPath).catch((err) => {\n        logger.warn(`Failed to clean up temp file: ${localPath}`, err);\n      });\n    }\n  }\n}\n", "/**\n * Encode a PowerShell script as a base64 string suitable for -EncodedCommand.\n * PowerShell expects UTF-16LE encoded base64.\n */\nexport function encodePowerShellCommand(script: string): string {\n  return Buffer.from(script, 'utf16le').toString('base64');\n}\n", "import { PowerShellClipboardReader } from \"./powershellClipboard\";\nimport { resolveToolPathOrFallback } from \"../util/toolPath\";\n\nexport class WindowsClipboardReader extends PowerShellClipboardReader {\n  private resolvedPsPath: string | undefined;\n\n  protected get powershellExe(): string {\n    // Return cached resolved path or fallback to bare name.\n    // Lazy resolution happens in readImage/hasImage via resolvePs().\n    return this.resolvedPsPath ?? \"powershell.exe\";\n  }\n\n  async resolvePs(): Promise<void> {\n    if (this.resolvedPsPath === undefined) {\n      this.resolvedPsPath = await resolveToolPathOrFallback(\"powershell.exe\");\n    }\n  }\n\n  requiredTool(): string {\n    return \"PowerShell (built-in)\";\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    await this.resolvePs();\n    return super.isToolAvailable();\n  }\n\n  protected async resolveTempPath(windowsPath: string): Promise<string> {\n    return windowsPath;\n  }\n}\n", "import { PowerShellClipboardReader } from \"./powershellClipboard\";\nimport { PlatformInfo } from \"../platform/detect\";\nimport { exec } from \"../util/exec\";\n\nexport class WslClipboardReader extends PowerShellClipboardReader {\n  private readonly psPath: string;\n\n  constructor(platform: PlatformInfo) {\n    super();\n    this.psPath = platform.powershellPath ?? \"powershell.exe\";\n  }\n\n  protected get powershellExe(): string {\n    return this.psPath;\n  }\n\n  requiredTool(): string {\n    return \"PowerShell (via WSL interop)\";\n  }\n\n  protected async resolveTempPath(windowsPath: string): Promise<string> {\n    try {\n      const result = await exec(\"wslpath\", [\"-u\", windowsPath]);\n      return result.stdout.trim();\n    } catch (err) {\n      throw new Error(\n        `wslpath conversion failed: could not convert \"${windowsPath}\" to a WSL path: ${err instanceof Error ? err.message : err}`,\n      );\n    }\n  }\n}\n", "import { ClipboardReader, ClipboardFormat, ClipboardImageResult } from \"./types\";\nimport { logger } from \"../util/logger\";\n\n/**\n * Tries each reader in order. The first reader whose operation succeeds wins.\n * If all readers fail, throws an aggregate error with details from each.\n */\nexport class FallbackClipboardReader implements ClipboardReader {\n  private readers: ClipboardReader[];\n\n  constructor(readers: ClipboardReader[]) {\n    if (readers.length === 0) {\n      throw new Error(\"FallbackClipboardReader requires at least one reader\");\n    }\n    this.readers = readers;\n  }\n\n  /** Expose the ordered reader chain for diagnostics. */\n  getReaders(): readonly ClipboardReader[] {\n    return this.readers;\n  }\n\n  requiredTool(): string {\n    return this.readers.map((r) => r.requiredTool()).join(\" or \");\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    for (const reader of this.readers) {\n      if (await reader.isToolAvailable()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  async hasImage(): Promise<boolean> {\n    for (const reader of this.readers) {\n      try {\n        if (await reader.hasImage()) {\n          return true;\n        }\n      } catch (err) {\n        logger.warn(`Clipboard reader ${reader.requiredTool()} failed hasImage()`, err);\n      }\n    }\n    return false;\n  }\n\n  async detectFormat(): Promise<ClipboardFormat> {\n    const errors: Error[] = [];\n    for (const reader of this.readers) {\n      try {\n        return await reader.detectFormat();\n      } catch (err) {\n        errors.push(err instanceof Error ? err : new Error(String(err)));\n      }\n    }\n    throw new AggregateError(\n      errors,\n      `All clipboard readers failed to detect format: ${errors.map((e) => e.message).join(\"; \")}`,\n    );\n  }\n\n  async readImage(): Promise<ClipboardImageResult> {\n    const errors: Error[] = [];\n    for (const reader of this.readers) {\n      try {\n        return await reader.readImage();\n      } catch (err) {\n        errors.push(err instanceof Error ? err : new Error(String(err)));\n      }\n    }\n    throw new AggregateError(\n      errors,\n      `All clipboard readers failed: ${errors.map((e) => e.message).join(\"; \")}`,\n    );\n  }\n}\n", "import * as fs from \"fs\";\nimport * as path from \"path\";\nimport { ClipboardReader, ClipboardFormat, ClipboardImageResult } from \"./types\";\nimport { exec } from \"../util/exec\";\nimport { encodePowerShellCommand } from \"../util/powershell\";\nimport { PlatformInfo } from \"../platform/detect\";\nimport { logger } from \"../util/logger\";\n\n/** Map from lowercase file extension to ClipboardFormat. */\nconst EXT_FORMAT_MAP: Record<string, ClipboardFormat> = {\n  \".png\": \"png\",\n  \".jpg\": \"jpeg\",\n  \".jpeg\": \"jpeg\",\n  \".bmp\": \"bmp\",\n  \".webp\": \"webp\",\n  \".tiff\": \"tiff\",\n  \".tif\": \"tiff\",\n  \".gif\": \"gif\",\n};\n\n/** Convert a file:// URI to a filesystem path. */\nfunction fileUriToPath(uri: string): string {\n  const parsed = new URL(uri);\n  // decodeURIComponent handles %20 etc. in the path\n  return decodeURIComponent(parsed.pathname);\n}\n\n/**\n * Abstract base class for clipboard readers that check for copied file paths\n * pointing to image files. Subclasses implement `getFilePaths()` to retrieve\n * the list of file paths from the platform clipboard.\n */\nexport abstract class FilePathClipboardReader implements ClipboardReader {\n  abstract requiredTool(): string;\n  abstract isToolAvailable(): Promise<boolean>;\n\n  /** Return file paths currently on the clipboard, or empty array if none. */\n  protected abstract getFilePaths(): Promise<string[]>;\n\n  /** Find the first image file path from a list of paths. */\n  protected findFirstImageFile(paths: string[]): { filePath: string; format: ClipboardFormat } | null {\n    for (const p of paths) {\n      const ext = path.extname(p).toLowerCase();\n      const format = EXT_FORMAT_MAP[ext];\n      if (format) {\n        return { filePath: p, format };\n      }\n    }\n    return null;\n  }\n\n  async hasImage(): Promise<boolean> {\n    try {\n      const paths = await this.getFilePaths();\n      return this.findFirstImageFile(paths) !== null;\n    } catch {\n      return false;\n    }\n  }\n\n  async detectFormat(): Promise<ClipboardFormat> {\n    const paths = await this.getFilePaths();\n    const found = this.findFirstImageFile(paths);\n    if (found) {\n      return found.format;\n    }\n    throw new Error(\"No image file path found in clipboard\");\n  }\n\n  async readImage(): Promise<ClipboardImageResult> {\n    const paths = await this.getFilePaths();\n    const found = this.findFirstImageFile(paths);\n    if (!found) {\n      throw new Error(\"No image file path found in clipboard\");\n    }\n    const data = await fs.promises.readFile(found.filePath);\n    return { data, format: found.format };\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Linux: xclip / wl-paste with text/uri-list target\n// ---------------------------------------------------------------------------\n\nexport class LinuxFilePathReader extends FilePathClipboardReader {\n  private displayServer: PlatformInfo[\"displayServer\"];\n\n  constructor(displayServer: PlatformInfo[\"displayServer\"]) {\n    super();\n    this.displayServer = displayServer;\n  }\n\n  private isWayland(): boolean {\n    return this.displayServer === \"wayland\";\n  }\n\n  requiredTool(): string {\n    return this.isWayland()\n      ? \"wl-clipboard (wl-paste) [file paths]\"\n      : \"xclip [file paths]\";\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    try {\n      const tool = this.isWayland() ? \"wl-paste\" : \"xclip\";\n      await exec(\"which\", [tool]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  protected async getFilePaths(): Promise<string[]> {\n    const { stdout } = this.isWayland()\n      ? await exec(\"wl-paste\", [\"--type\", \"text/uri-list\"])\n      : await exec(\"xclip\", [\"-selection\", \"clipboard\", \"-t\", \"text/uri-list\", \"-o\"]);\n\n    return stdout\n      .split(\"\\n\")\n      .map((line) => line.trim())\n      .filter((line) => line.startsWith(\"file://\"))\n      .map(fileUriToPath);\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Windows: PowerShell GetFileDropList()\n// ---------------------------------------------------------------------------\n\nconst PS_GET_FILE_DROP_LIST =\n  \"Add-Type -AssemblyName System.Windows.Forms; $files = [System.Windows.Forms.Clipboard]::GetFileDropList(); foreach ($f in $files) { Write-Output $f }\";\n\nexport class WindowsFilePathReader extends FilePathClipboardReader {\n  requiredTool(): string {\n    return \"PowerShell (built-in) [file paths]\";\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    try {\n      await exec(\"powershell.exe\", [\"-Command\", \"echo ok\"]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  protected async getFilePaths(): Promise<string[]> {\n    const { stdout } = await exec(\"powershell.exe\", [\n      \"-EncodedCommand\",\n      encodePowerShellCommand(PS_GET_FILE_DROP_LIST),\n    ]);\n    return stdout\n      .split(\"\\n\")\n      .map((line) => line.trim())\n      .filter((line) => line.length > 0);\n  }\n}\n\n// ---------------------------------------------------------------------------\n// WSL: PowerShell GetFileDropList() + wslpath conversion\n// ---------------------------------------------------------------------------\n\nexport class WslFilePathReader extends FilePathClipboardReader {\n  private readonly psPath: string;\n\n  constructor(platform: PlatformInfo) {\n    super();\n    this.psPath = platform.powershellPath ?? \"powershell.exe\";\n  }\n\n  requiredTool(): string {\n    return \"PowerShell (via WSL interop) [file paths]\";\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    try {\n      await exec(this.psPath, [\"-Command\", \"echo ok\"]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  protected async getFilePaths(): Promise<string[]> {\n    const { stdout } = await exec(this.psPath, [\n      \"-EncodedCommand\",\n      encodePowerShellCommand(PS_GET_FILE_DROP_LIST),\n    ]);\n\n    const windowsPaths = stdout\n      .split(\"\\n\")\n      .map((line) => line.trim())\n      .filter((line) => line.length > 0);\n\n    // Convert Windows paths to WSL paths\n    const wslPaths: string[] = [];\n    for (const winPath of windowsPaths) {\n      try {\n        const { stdout: wslPath } = await exec(\"wslpath\", [\"-u\", winPath]);\n        wslPaths.push(wslPath.trim());\n      } catch (err) {\n        logger.warn(`wslpath conversion failed for \"${winPath}\":`, err);\n      }\n    }\n    return wslPaths;\n  }\n}\n\n// ---------------------------------------------------------------------------\n// macOS: osascript with \u00ABclass furl\u00BB\n// ---------------------------------------------------------------------------\n\nexport class MacosFilePathReader extends FilePathClipboardReader {\n  requiredTool(): string {\n    return \"osascript (built-in) [file paths]\";\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    return process.platform === \"darwin\";\n  }\n\n  protected async getFilePaths(): Promise<string[]> {\n    // Get file URLs from the clipboard using the furl class\n    const { stdout } = await exec(\"osascript\", [\n      \"-e\",\n      \"try\",\n      \"-e\",\n      \"  set fileList to (the clipboard as \u00ABclass furl\u00BB)\",\n      \"-e\",\n      \"  return POSIX path of fileList\",\n      \"-e\",\n      \"on error\",\n      \"-e\",\n      \"  return \\\"\\\"\",\n      \"-e\",\n      \"end try\",\n    ]);\n\n    const trimmed = stdout.trim();\n    if (!trimmed) {\n      return [];\n    }\n    return [trimmed];\n  }\n}\n", "import { PlatformInfo } from \"../platform/detect\";\nimport { ClipboardReader } from \"./types\";\nimport { MacosClipboardReader } from \"./macosClipboard\";\nimport { MacosOsascriptClipboardReader } from \"./macosOsascriptClipboard\";\nimport { LinuxClipboardReader } from \"./linuxClipboard\";\nimport { WindowsClipboardReader } from \"./windowsClipboard\";\nimport { WslClipboardReader } from \"./wslClipboard\";\nimport { FallbackClipboardReader } from \"./fallback\";\nimport {\n  LinuxFilePathReader,\n  WindowsFilePathReader,\n  WslFilePathReader,\n  MacosFilePathReader,\n} from \"./filePathClipboard\";\n\nexport { ClipboardReader } from \"./types\";\n\nexport function createClipboardReader(platform: PlatformInfo): ClipboardReader {\n  if (platform.isWSL) {\n    const hasDisplayServer =\n      platform.displayServer === \"x11\" || platform.displayServer === \"wayland\";\n\n    // When WSLg is available, prefer native Linux clipboard tools (faster, more\n    // reliable) over PowerShell interop, falling back to PowerShell.\n    // Without WSLg, PowerShell interop is the primary (and possibly only) reader.\n    if (platform.hasWslg && hasDisplayServer) {\n      return new FallbackClipboardReader([\n        new LinuxClipboardReader(platform.displayServer),\n        new WslClipboardReader(platform),\n        new LinuxFilePathReader(platform.displayServer),\n        new WslFilePathReader(platform),\n      ]);\n    }\n\n    const readers: ClipboardReader[] = [new WslClipboardReader(platform)];\n    if (hasDisplayServer) {\n      readers.push(new LinuxClipboardReader(platform.displayServer));\n    }\n    // File-path readers always go last in the chain\n    readers.push(new WslFilePathReader(platform));\n    if (hasDisplayServer) {\n      readers.push(new LinuxFilePathReader(platform.displayServer));\n    }\n\n    return new FallbackClipboardReader(readers);\n  }\n\n  switch (platform.os) {\n    case \"macos\":\n      return new FallbackClipboardReader([\n        new MacosClipboardReader(),\n        new MacosOsascriptClipboardReader(),\n        new MacosFilePathReader(),\n      ]);\n    case \"windows\":\n      return new FallbackClipboardReader([\n        new WindowsClipboardReader(),\n        new WindowsFilePathReader(),\n      ]);\n    case \"linux\": {\n      const primary = new LinuxClipboardReader(platform.displayServer);\n      const fallbackDS =\n        platform.displayServer === \"wayland\" ? \"x11\" : \"wayland\";\n      const fallback = new LinuxClipboardReader(fallbackDS);\n      return new FallbackClipboardReader([\n        primary,\n        fallback,\n        new LinuxFilePathReader(platform.displayServer),\n      ]);\n    }\n  }\n}\n", "import * as crypto from 'crypto';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as vscode from 'vscode';\nimport { logger } from '../util/logger';\nimport { writeSecureFile } from '../util/fs';\nimport type { ClipboardFormat } from '../clipboard/types';\n\nexport type OrganizeFolders = 'flat' | 'daily' | 'monthly';\n\nexport interface ImageStore {\n  /** Save an image buffer to the image folder. Returns the absolute file path. */\n  save(imageBuffer: Buffer, format?: ClipboardFormat): Promise<string>;\n\n  /** Delete the oldest images if count exceeds maxImages setting. */\n  cleanup(): Promise<void>;\n\n  /** Ensure the image folder is listed in .gitignore (if autoGitIgnore is enabled). */\n  ensureGitIgnored(): Promise<void>;\n}\n\nconst DEFAULT_FOLDER_NAME = '.tip-images';\n\n/** All image file extensions managed by this store. */\nexport const IMAGE_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.tiff', '.tif', '.bmp', '.webp', '.gif'];\n\n/** Map from ClipboardFormat to file extension. */\nfunction formatToExtension(format: ClipboardFormat): string {\n  switch (format) {\n    case 'jpeg':\n      return '.jpg';\n    case 'tiff':\n      return '.tiff';\n    case 'bmp':\n      return '.bmp';\n    case 'webp':\n      return '.webp';\n    case 'gif':\n      return '.gif';\n    case 'png':\n    case 'unknown':\n    default:\n      return '.png';\n  }\n}\n\n/** First 8 bytes of every valid PNG file. */\nconst PNG_SIGNATURE = Buffer.from([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n\n/** Validate image data matches the expected format's magic bytes. */\nfunction validateImage(buffer: Buffer, format: ClipboardFormat): void {\n  switch (format) {\n    case 'png':\n      if (buffer.length < PNG_SIGNATURE.length || !buffer.subarray(0, PNG_SIGNATURE.length).equals(PNG_SIGNATURE)) {\n        throw new Error('Clipboard data is not a valid PNG image');\n      }\n      break;\n    case 'jpeg':\n      if (buffer.length < 2 || buffer[0] !== 0xff || buffer[1] !== 0xd8) {\n        throw new Error('Clipboard data is not a valid JPEG image');\n      }\n      break;\n    case 'bmp':\n      if (buffer.length < 2 || buffer[0] !== 0x42 || buffer[1] !== 0x4d) {\n        throw new Error('Clipboard data is not a valid BMP image');\n      }\n      break;\n    case 'webp':\n      if (\n        buffer.length < 12 ||\n        buffer.subarray(0, 4).toString('ascii') !== 'RIFF' ||\n        buffer.subarray(8, 12).toString('ascii') !== 'WEBP'\n      ) {\n        throw new Error('Clipboard data is not a valid WebP image');\n      }\n      break;\n    case 'tiff':\n      if (\n        buffer.length < 2 ||\n        !(\n          (buffer[0] === 0x49 && buffer[1] === 0x49) ||\n          (buffer[0] === 0x4d && buffer[1] === 0x4d)\n        )\n      ) {\n        throw new Error('Clipboard data is not a valid TIFF image');\n      }\n      break;\n    case 'gif':\n      if (buffer.length < 3 || buffer.subarray(0, 3).toString('ascii') !== 'GIF') {\n        throw new Error('Clipboard data is not a valid GIF image');\n      }\n      break;\n    case 'unknown':\n      logger.warn('Skipping image validation for unknown format');\n      break;\n  }\n}\n\nfunction getConfig(): vscode.WorkspaceConfiguration {\n  return vscode.workspace.getConfiguration('terminalImgPaste');\n}\n\nfunction getWorkspaceRoot(): string {\n  const folders = vscode.workspace.workspaceFolders;\n  if (!folders || folders.length === 0) {\n    throw new Error('No workspace folder is open. Please open a folder first.');\n  }\n  return folders[0].uri.fsPath;\n}\n\nfunction getFolderName(): string {\n  return getConfig().get<string>('folderName', DEFAULT_FOLDER_NAME);\n}\n\nfunction getImageFolderPath(): string {\n  const root = getWorkspaceRoot();\n  const folderName = getFolderName();\n  const resolved = path.resolve(root, folderName);\n  if (!resolved.startsWith(root + path.sep)) {\n    throw new Error(\n      `Configured folderName \"${folderName}\" must resolve to a subdirectory of the workspace root`,\n    );\n  }\n  return resolved;\n}\n\nconst DEFAULT_FILENAME_PATTERN = 'img-{timestamp}';\n\n/** Placeholders that guarantee unique filenames for rapid consecutive pastes. */\nconst UNIQUENESS_PLACEHOLDERS = ['{timestamp}', '{n}', '{hash}'];\n\n/**\n * Resolve a filename pattern by replacing placeholders with actual values.\n * Exported for unit testing.\n */\nexport function resolveFilenamePattern(\n  pattern: string,\n  imageBuffer: Buffer,\n  existingFiles: string[],\n): string {\n  if (!pattern) {\n    pattern = DEFAULT_FILENAME_PATTERN;\n  }\n\n  const now = new Date();\n\n  const hasPlaceholder = pattern.includes('{');\n  if (!hasPlaceholder) {\n    // No placeholders at all \u2014 append timestamp to avoid collisions\n    const ts = formatTimestamp(now);\n    pattern = `${pattern}-${ts}`;\n  } else if (!UNIQUENESS_PLACEHOLDERS.some((p) => pattern.includes(p))) {\n    logger.warn(\n      `Filename pattern \"${pattern}\" lacks a uniqueness placeholder (${UNIQUENESS_PLACEHOLDERS.join(', ')}). Filenames may collide.`,\n    );\n  }\n  let result = pattern;\n\n  // {timestamp}\n  result = result.replace(/\\{timestamp\\}/g, formatTimestamp(now));\n\n  // {date}\n  result = result.replace(/\\{date\\}/g, formatDate(now));\n\n  // {time}\n  result = result.replace(/\\{time\\}/g, formatTime(now));\n\n  // {hash}\n  if (result.includes('{hash}')) {\n    const hash = crypto.createHash('sha256').update(imageBuffer).digest('hex').slice(0, 8);\n    result = result.replace(/\\{hash\\}/g, hash);\n  }\n\n  // {n}\n  if (result.includes('{n}')) {\n    result = resolveSequentialNumber(result, existingFiles);\n  }\n\n  return result;\n}\n\nfunction formatTimestamp(now: Date): string {\n  const ms = String(now.getMilliseconds()).padStart(3, '0');\n  return `${formatDate(now)}T${formatTime(now)}-${ms}`;\n}\n\nfunction formatDate(now: Date): string {\n  const y = now.getFullYear();\n  const mo = String(now.getMonth() + 1).padStart(2, '0');\n  const d = String(now.getDate()).padStart(2, '0');\n  return `${y}-${mo}-${d}`;\n}\n\nfunction formatTime(now: Date): string {\n  const h = String(now.getHours()).padStart(2, '0');\n  const mi = String(now.getMinutes()).padStart(2, '0');\n  const s = String(now.getSeconds()).padStart(2, '0');\n  return `${h}-${mi}-${s}`;\n}\n\n/**\n * Replace `{n}` with the next sequential number.\n * Scans existing files in the folder to determine the highest number used so far.\n */\nfunction resolveSequentialNumber(pattern: string, existingFiles: string[]): string {\n  // Build a regex from the pattern that captures the number where {n} is\n  const escaped = pattern\n    .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n    .replace(/\\\\{n\\\\}/g, '(\\\\d+)');\n  const regex = new RegExp(`^${escaped}`);\n\n  let maxN = 0;\n  for (const file of existingFiles) {\n    // Strip extension for matching\n    const baseName = file.replace(/\\.[^.]+$/, '');\n    const match = baseName.match(regex);\n    if (match && match[1]) {\n      const num = parseInt(match[1], 10);\n      if (num > maxN) {\n        maxN = num;\n      }\n    }\n  }\n\n  return pattern.replace(/\\{n\\}/g, String(maxN + 1));\n}\n\nfunction generateFileName(\n  format: ClipboardFormat,\n  imageBuffer: Buffer,\n  existingFiles: string[],\n): string {\n  const pattern = getConfig().get<string>('filenamePattern', DEFAULT_FILENAME_PATTERN);\n  const baseName = resolveFilenamePattern(pattern, imageBuffer, existingFiles);\n  const ext = formatToExtension(format);\n  return `${baseName}${ext}`;\n}\n\n/**\n * Verify that `target` is inside `root` after resolving symlinks.\n * On case-insensitive filesystems (Windows/macOS) paths are lowercased before\n * comparison; on Linux (case-sensitive) exact casing is preserved.\n * Throws if the resolved path escapes the workspace.\n */\nasync function assertInsideWorkspace(target: string, root: string): Promise<string> {\n  const realTarget = await fs.promises.realpath(target);\n  const realRoot = await fs.promises.realpath(root);\n  // Only normalise case on case-insensitive filesystems (Windows, macOS).\n  // Linux is case-sensitive so lowercasing would bypass the check.\n  const caseInsensitive = process.platform === 'win32' || process.platform === 'darwin';\n  const normTarget = caseInsensitive ? realTarget.toLowerCase() : realTarget;\n  const normRoot = caseInsensitive ? realRoot.toLowerCase() : realRoot;\n  if (normTarget !== normRoot && !normTarget.startsWith(normRoot + path.sep)) {\n    throw new Error(\n      `Image folder resolves to a path outside the workspace (possible symlink escape): ${realTarget}`,\n    );\n  }\n  return realTarget;\n}\n\n/**\n * Compute the subdirectory name based on the organizeFolders setting.\n * Exported for unit testing.\n */\nexport function getSubdirectory(organize: OrganizeFolders, now: Date = new Date()): string {\n  switch (organize) {\n    case 'daily':\n      return formatDate(now);\n    case 'monthly':\n      return formatDate(now).substring(0, 7);\n    case 'flat':\n    default:\n      return '';\n  }\n}\n\n/** Recursively collect all image files under a directory (skips symlinks). */\nexport async function collectImagesRecursive(folder: string): Promise<{ filePath: string; name: string }[]> {\n  const results: { filePath: string; name: string }[] = [];\n  let entries: fs.Dirent[];\n  try {\n    entries = await fs.promises.readdir(folder, { withFileTypes: true });\n  } catch {\n    return results;\n  }\n  for (const entry of entries) {\n    const fullPath = path.join(folder, entry.name);\n    if (entry.isDirectory() && !entry.isSymbolicLink()) {\n      results.push(...(await collectImagesRecursive(fullPath)));\n    } else if (!entry.isSymbolicLink() && IMAGE_EXTENSIONS.some((ext) => entry.name.endsWith(ext))) {\n      results.push({ filePath: fullPath, name: entry.name });\n    }\n  }\n  return results;\n}\n\n/** Remove a directory if it is empty. Never removes the root image folder. */\nasync function removeEmptyDirs(dir: string, rootFolder: string): Promise<void> {\n  if (dir === rootFolder) return;\n  try {\n    const remaining = await fs.promises.readdir(dir);\n    if (remaining.length === 0) {\n      await fs.promises.rmdir(dir);\n      logger.info(`Removed empty directory: ${dir}`);\n    }\n  } catch (err) {\n    logger.warn(`Failed to remove empty directory ${dir}:`, err);\n  }\n}\n\nexport function createImageStore(): ImageStore {\n  return {\n    async save(imageBuffer: Buffer, format: ClipboardFormat = 'png'): Promise<string> {\n      if (imageBuffer.length === 0) {\n        throw new Error('Cannot save empty image data');\n      }\n      validateImage(imageBuffer, format);\n\n      const folder = getImageFolderPath();\n      const root = getWorkspaceRoot();\n      await fs.promises.mkdir(folder, { recursive: true });\n\n      // Verify the resolved folder stays within the workspace\n      await assertInsideWorkspace(folder, root);\n\n      // Determine subdirectory based on organizeFolders setting\n      const organize = getConfig().get<OrganizeFolders>('organizeFolders', 'flat');\n      const subdir = getSubdirectory(organize);\n      const saveFolder = subdir ? path.join(folder, subdir) : folder;\n\n      if (subdir) {\n        await fs.promises.mkdir(saveFolder, { recursive: true });\n        await assertInsideWorkspace(saveFolder, root);\n      }\n\n      let existingFiles: string[];\n      try {\n        existingFiles = await fs.promises.readdir(saveFolder);\n      } catch {\n        existingFiles = [];\n      }\n\n      const fileName = generateFileName(format, imageBuffer, existingFiles);\n      const requestedPath = path.join(saveFolder, fileName);\n      const filePath = await writeSecureFile(requestedPath, imageBuffer);\n\n      // Defense-in-depth: verify the saved file also stays within the workspace\n      await assertInsideWorkspace(filePath, root);\n\n      logger.info(`Saved image: ${filePath}`);\n\n      await this.cleanup();\n      await this.ensureGitIgnored();\n\n      return filePath;\n    },\n\n    async cleanup(): Promise<void> {\n      const config = getConfig();\n      const rawMaxImages = config.get<number>('maxImages', 20);\n      const maxImages =\n        Number.isInteger(rawMaxImages) && rawMaxImages > 0\n          ? rawMaxImages\n          : 20;\n      const organize = config.get<OrganizeFolders>('organizeFolders', 'flat');\n      const folder = getImageFolderPath();\n\n      if (organize === 'flat') {\n        // Flat cleanup \u2014 original logic\n        let entries: string[];\n        try {\n          entries = await fs.promises.readdir(folder);\n        } catch {\n          return;\n        }\n\n        const imageFiles = entries\n          .filter((f) => IMAGE_EXTENSIONS.some((ext) => f.endsWith(ext)))\n          .sort();\n\n        if (imageFiles.length <= maxImages) {\n          return;\n        }\n\n        const toDelete = imageFiles.slice(0, imageFiles.length - maxImages);\n        for (const file of toDelete) {\n          const filePath = path.join(folder, file);\n          try {\n            await fs.promises.unlink(filePath);\n            logger.info(`Deleted old image: ${filePath}`);\n          } catch (err) {\n            logger.warn(`Failed to delete old image: ${filePath}`, err);\n          }\n        }\n      } else {\n        // Recursive cleanup across subdirectories\n        const allImages = await collectImagesRecursive(folder);\n        allImages.sort((a, b) => a.name.localeCompare(b.name));\n\n        if (allImages.length <= maxImages) return;\n\n        const toDelete = allImages.slice(0, allImages.length - maxImages);\n        const affectedDirs = new Set<string>();\n\n        for (const img of toDelete) {\n          try {\n            await fs.promises.unlink(img.filePath);\n            logger.info(`Deleted old image: ${img.filePath}`);\n            affectedDirs.add(path.dirname(img.filePath));\n          } catch (err) {\n            logger.warn(`Failed to delete old image: ${img.filePath}`, err);\n          }\n        }\n\n        // Clean up empty subdirectories\n        for (const dir of affectedDirs) {\n          await removeEmptyDirs(dir, folder);\n        }\n      }\n    },\n\n    async ensureGitIgnored(): Promise<void> {\n      const config = getConfig();\n      if (!config.get<boolean>('autoGitIgnore', true)) {\n        return;\n      }\n\n      const folderName = getFolderName();\n      const workspaceRoot = getWorkspaceRoot();\n      const gitignorePath = path.join(workspaceRoot, '.gitignore');\n\n      let content: string;\n      try {\n        content = await fs.promises.readFile(gitignorePath, 'utf-8');\n      } catch {\n        await fs.promises.writeFile(gitignorePath, folderName + '\\n', 'utf-8');\n        logger.info(`Created .gitignore with ${folderName}`);\n        return;\n      }\n\n      const lines = content.split('\\n').map((line) => line.trim());\n      if (lines.includes(folderName)) {\n        return;\n      }\n\n      const suffix = content.endsWith('\\n') ? '' : '\\n';\n      await fs.promises.writeFile(\n        gitignorePath,\n        content + suffix + folderName + '\\n',\n        'utf-8',\n      );\n      logger.info(`Added ${folderName} to .gitignore`);\n    },\n  };\n}\n", "import * as fs from 'fs';\nimport * as path from 'path';\n\nconst MAX_COLLISION_RETRIES = 100;\n\n/**\n * Write a buffer to disk with restrictive permissions (owner read/write only)\n * using exclusive-create to prevent silently overwriting existing files.\n *\n * On filename collision, retries with `-1`, `-2`, \u2026 suffixes inserted before\n * the file extension. Returns the actual path written.\n */\nexport async function writeSecureFile(filePath: string, data: Buffer): Promise<string> {\n  try {\n    await fs.promises.writeFile(filePath, data, { flag: 'wx', mode: 0o600 });\n    return filePath;\n  } catch (err) {\n    if ((err as NodeJS.ErrnoException).code !== 'EEXIST') {\n      throw err;\n    }\n  }\n\n  // Collision \u2014 retry with incrementing suffix\n  const ext = path.extname(filePath);\n  const base = filePath.slice(0, filePath.length - ext.length);\n\n  for (let i = 1; i <= MAX_COLLISION_RETRIES; i++) {\n    const candidate = `${base}-${i}${ext}`;\n    try {\n      await fs.promises.writeFile(candidate, data, { flag: 'wx', mode: 0o600 });\n      return candidate;\n    } catch (err) {\n      if ((err as NodeJS.ErrnoException).code !== 'EEXIST') {\n        throw err;\n      }\n    }\n  }\n\n  throw new Error(`Unable to write file after ${MAX_COLLISION_RETRIES} retries: ${filePath}`);\n}\n", "import * as vscode from 'vscode';\nimport { logger } from '../util/logger';\nimport { detectShellType, type ShellType } from './shellDetect';\n\n/**\n * Quote a file path for safe insertion into a specific shell.\n */\nexport function quotePath(filePath: string, shell: ShellType): string {\n  switch (shell) {\n    case 'fish':\n      // Fish uses single quotes but escapes ' with \\'\n      return \"'\" + filePath.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\'\") + \"'\";\n    case 'powershell':\n      // PowerShell uses double quotes; escape ` with ``, $ with `$, \" with `\"\n      return '\"' + filePath.replace(/`/g, '``').replace(/\\$/g, '`$').replace(/\"/g, '`\"') + '\"';\n    case 'cmd':\n      // cmd uses double quotes; escape % with %%, \" with \"\"\n      return '\"' + filePath.replace(/%/g, '%%').replace(/\"/g, '\"\"') + '\"';\n    case 'bash':\n    case 'zsh':\n    case 'unknown':\n    default:\n      // Single-quote the path, escape embedded single quotes with '\\''\n      return \"'\" + filePath.replace(/'/g, \"'\\\\''\") + \"'\";\n  }\n}\n\n/**\n * Send a file path to the active terminal.\n * Detects the shell type and applies the correct quoting strategy.\n * Reads `sendNewline` setting to decide whether to append a newline.\n */\nexport function insertPathToTerminal(filePath: string): void {\n  const terminal = vscode.window.activeTerminal;\n  if (!terminal) {\n    vscode.window.showErrorMessage(\n      'Terminal Image Paste: No active terminal. Please open a terminal first.',\n    );\n    return;\n  }\n\n  const shellType = detectShellType(terminal);\n  const text = quotePath(filePath, shellType);\n\n  const config = vscode.workspace.getConfiguration('terminalImgPaste');\n  const addNewline = config.get<boolean>('sendNewline', false);\n\n  terminal.sendText(text, addNewline);\n  logger.info(`Inserted path into terminal (${shellType}): ${text}`);\n}\n", "import * as vscode from 'vscode';\nimport * as path from 'path';\n\nexport type ShellType = 'bash' | 'zsh' | 'fish' | 'powershell' | 'cmd' | 'unknown';\n\nconst shellPatterns: Array<{ pattern: RegExp; type: ShellType }> = [\n  { pattern: /\\bbash\\b/i, type: 'bash' },\n  { pattern: /\\bzsh\\b/i, type: 'zsh' },\n  { pattern: /\\bfish\\b/i, type: 'fish' },\n  { pattern: /\\b(?:pwsh|powershell)\\b/i, type: 'powershell' },\n  { pattern: /\\bcmd\\b/i, type: 'cmd' },\n];\n\nfunction matchShell(shellPath: string): ShellType {\n  const base = path.basename(shellPath).replace(/\\.exe$/i, '');\n  for (const { pattern, type } of shellPatterns) {\n    if (pattern.test(base)) {\n      return type;\n    }\n  }\n  return 'unknown';\n}\n\nexport function detectShellType(terminal: vscode.Terminal): ShellType {\n  // 1. Check terminal's explicit shell path\n  const shellPath = (terminal.creationOptions as vscode.TerminalOptions)?.shellPath;\n  if (shellPath) {\n    return matchShell(shellPath);\n  }\n\n  // 2. Fall back to SHELL environment variable\n  const envShell = process.env.SHELL;\n  if (envShell) {\n    return matchShell(envShell);\n  }\n\n  // 3. Windows default: PowerShell\n  if (process.platform === 'win32') {\n    return 'powershell';\n  }\n\n  return 'unknown';\n}\n", "import * as fs from 'fs';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { PlatformInfo } from '../platform/detect';\nimport { ClipboardFormat } from '../clipboard/types';\nimport { exec, execBuffer } from '../util/exec';\nimport { writeSecureFile } from '../util/fs';\nimport { encodePowerShellCommand } from '../util/powershell';\nimport { logger } from '../util/logger';\n\nexport type SaveFormat = 'auto' | 'png' | 'jpeg';\n\nexport interface ConversionResult {\n  data: Buffer;\n  format: ClipboardFormat;\n}\n\ntype ConversionTool = 'sips' | 'magick' | 'ffmpeg' | 'powershell';\n\n/**\n * If conversion is needed (saveFormat !== 'auto' and differs from source format),\n * convert using platform-native tools. Returns original data if:\n * - saveFormat is 'auto'\n * - source format already matches target\n * - conversion tool is unavailable (with a warning logged)\n */\nexport async function convertImage(\n  data: Buffer,\n  sourceFormat: ClipboardFormat,\n  targetFormat: SaveFormat,\n  platform: PlatformInfo,\n): Promise<ConversionResult> {\n  if (targetFormat === 'auto' || sourceFormat === targetFormat) {\n    return { data, format: sourceFormat };\n  }\n\n  try {\n    const converted = await convertWithPlatformTool(\n      data,\n      sourceFormat,\n      targetFormat,\n      platform,\n    );\n    return { data: converted, format: targetFormat };\n  } catch (err) {\n    logger.warn(\n      `Image conversion from ${sourceFormat} to ${targetFormat} failed, saving in native format: ${err instanceof Error ? err.message : String(err)}`,\n    );\n    return { data, format: sourceFormat };\n  }\n}\n\nasync function findConversionTool(\n  platform: PlatformInfo,\n): Promise<ConversionTool | null> {\n  if (platform.os === 'macos') {\n    return 'sips';\n  }\n\n  if (platform.os === 'windows' || platform.isWSL) {\n    if (platform.powershellPath) {\n      return 'powershell';\n    }\n    return null;\n  }\n\n  // Linux: try ImageMagick first, then ffmpeg\n  try {\n    await exec('which', ['convert']);\n    return 'magick';\n  } catch {\n    /* not found */\n  }\n  try {\n    await exec('which', ['ffmpeg']);\n    return 'ffmpeg';\n  } catch {\n    /* not found */\n  }\n  return null;\n}\n\nasync function convertWithPlatformTool(\n  data: Buffer,\n  sourceFormat: ClipboardFormat,\n  targetFormat: SaveFormat,\n  platform: PlatformInfo,\n): Promise<Buffer> {\n  const tool = await findConversionTool(platform);\n\n  if (tool === null) {\n    throw new Error('No conversion tool available');\n  }\n\n  switch (tool) {\n    case 'sips':\n      return convertWithSips(data, targetFormat);\n    case 'magick':\n      return convertWithMagick(data, sourceFormat, targetFormat);\n    case 'ffmpeg':\n      return convertWithFfmpeg(data, targetFormat);\n    case 'powershell':\n      return convertWithPowershell(data, targetFormat, platform.powershellPath!);\n  }\n}\n\nasync function convertWithSips(\n  data: Buffer,\n  targetFormat: SaveFormat,\n): Promise<Buffer> {\n  const tmpDir = os.tmpdir();\n  const inputPath = path.join(tmpDir, `tip-convert-in-${Date.now()}`);\n  const targetExt = targetFormat === 'jpeg' ? 'jpg' : 'png';\n  const outputPath = path.join(tmpDir, `tip-convert-out-${Date.now()}.${targetExt}`);\n\n  const actualInputPath = await writeSecureFile(inputPath, data);\n  try {\n    const sipsFormat = targetFormat === 'jpeg' ? 'jpeg' : 'png';\n    await exec('sips', [\n      '--setProperty',\n      'format',\n      sipsFormat,\n      actualInputPath,\n      '--out',\n      outputPath,\n    ]);\n    return await fs.promises.readFile(outputPath);\n  } finally {\n    await fs.promises.unlink(actualInputPath).catch(() => {});\n    await fs.promises.unlink(outputPath).catch(() => {});\n  }\n}\n\nasync function convertWithMagick(\n  data: Buffer,\n  sourceFormat: ClipboardFormat,\n  targetFormat: SaveFormat,\n): Promise<Buffer> {\n  const inputSpec = sourceFormat === 'unknown' ? '-' : `${sourceFormat}:-`;\n  const outputSpec = `${targetFormat}:-`;\n  const result = await execBuffer('convert', [inputSpec, outputSpec], {\n    input: data,\n  });\n  return result.stdout;\n}\n\nasync function convertWithFfmpeg(\n  data: Buffer,\n  targetFormat: SaveFormat,\n): Promise<Buffer> {\n  const codec = targetFormat === 'png' ? 'png' : 'mjpeg';\n  const result = await execBuffer(\n    'ffmpeg',\n    [\n      '-hide_banner',\n      '-loglevel',\n      'error',\n      '-f',\n      'image2pipe',\n      '-i',\n      '-',\n      '-f',\n      'image2',\n      '-c:v',\n      codec,\n      '-',\n    ],\n    { input: data },\n  );\n  return result.stdout;\n}\n\nasync function convertWithPowershell(\n  data: Buffer,\n  targetFormat: SaveFormat,\n  powershellPath: string,\n): Promise<Buffer> {\n  const formatEnum = targetFormat === 'png' ? 'Png' : 'Jpeg';\n  const script = `\nAdd-Type -AssemblyName System.Drawing\n$stdin = [Console]::OpenStandardInput()\n$ms = New-Object System.IO.MemoryStream\n$stdin.CopyTo($ms)\n$ms.Position = 0\n$img = [System.Drawing.Image]::FromStream($ms)\n$outMs = New-Object System.IO.MemoryStream\n$img.Save($outMs, [System.Drawing.Imaging.ImageFormat]::${formatEnum})\n[Console]::OpenStandardOutput().Write($outMs.ToArray(), 0, $outMs.Length)\n$img.Dispose()\n$ms.Dispose()\n$outMs.Dispose()\n`;\n  const result = await execBuffer(\n    powershellPath,\n    ['-NoProfile', '-EncodedCommand', encodePowerShellCommand(script)],\n    { input: data },\n  );\n  return result.stdout;\n}\n", "import * as vscode from 'vscode';\nimport type { ClipboardFormat } from '../clipboard/types';\n\nconst TIMEOUT_MS = 10_000;\n\n/**\n * Show a webview panel previewing the clipboard image.\n * Resolves `true` if the user confirms, `false` if they cancel or the panel times out / is closed.\n */\nexport function showImagePreview(\n  imageData: Buffer,\n  format: ClipboardFormat,\n): Promise<boolean> {\n  return new Promise<boolean>((resolve) => {\n    let resolved = false;\n    let timer: ReturnType<typeof setTimeout> | undefined = undefined;\n    const finish = (value: boolean) => {\n      if (resolved) return;\n      resolved = true;\n      clearTimeout(timer);\n      panel.dispose();\n      resolve(value);\n    };\n\n    const panel = vscode.window.createWebviewPanel(\n      'terminalImgPaste.preview',\n      'Image Preview \u2014 Terminal Image Paste',\n      vscode.ViewColumn.Active,\n      { enableScripts: true },\n    );\n\n    const mimeType = format === 'unknown' ? 'image/png' : `image/${format}`;\n    const base64 = imageData.toString('base64');\n\n    panel.webview.html = buildHtml(mimeType, base64, TIMEOUT_MS);\n\n    panel.webview.onDidReceiveMessage((msg: { command: string }) => {\n      if (msg.command === 'paste') {\n        finish(true);\n      } else if (msg.command === 'cancel' || msg.command === 'timeout') {\n        finish(false);\n      }\n    });\n\n    panel.onDidDispose(() => {\n      finish(false);\n    });\n\n    timer = setTimeout(() => {\n      finish(false);\n    }, TIMEOUT_MS + 500); // small buffer beyond the client-side countdown\n  });\n}\n\nfunction buildHtml(mimeType: string, base64: string, timeoutMs: number): string {\n  const timeoutSec = Math.round(timeoutMs / 1000);\n  return `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"Content-Security-Policy\"\n        content=\"default-src 'none'; img-src data:; style-src 'unsafe-inline'; script-src 'unsafe-inline';\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Image Preview</title>\n  <style>\n    body { font-family: var(--vscode-font-family, sans-serif); padding: 16px; text-align: center; color: var(--vscode-foreground); background: var(--vscode-editor-background); }\n    img { max-width: 100%; max-height: 60vh; border: 1px solid var(--vscode-panel-border, #444); margin-bottom: 12px; }\n    .info { margin-bottom: 16px; opacity: 0.8; font-size: 13px; }\n    .buttons { display: flex; justify-content: center; gap: 12px; }\n    button { padding: 8px 20px; font-size: 14px; cursor: pointer; border: none; border-radius: 4px; }\n    .btn-paste { background: var(--vscode-button-background, #0078d4); color: var(--vscode-button-foreground, #fff); }\n    .btn-paste:hover { background: var(--vscode-button-hoverBackground, #005a9e); }\n    .btn-cancel { background: var(--vscode-button-secondaryBackground, #333); color: var(--vscode-button-secondaryForeground, #fff); }\n    .btn-cancel:hover { background: var(--vscode-button-secondaryHoverBackground, #444); }\n    .countdown { margin-top: 12px; font-size: 12px; opacity: 0.6; }\n  </style>\n</head>\n<body>\n  <img id=\"preview\" src=\"data:${mimeType};base64,${base64}\" alt=\"Clipboard image preview\"\n       onload=\"document.getElementById('dims').textContent = this.naturalWidth + ' \u00D7 ' + this.naturalHeight + ' px';\" />\n  <div class=\"info\" id=\"dims\"></div>\n  <div class=\"buttons\">\n    <button class=\"btn-paste\" id=\"pasteBtn\">Paste</button>\n    <button class=\"btn-cancel\" id=\"cancelBtn\">Cancel</button>\n  </div>\n  <div class=\"countdown\" id=\"timer\">Auto-cancel in ${timeoutSec}s</div>\n  <script>\n    const vscode = acquireVsCodeApi();\n    document.getElementById('pasteBtn').addEventListener('click', () => vscode.postMessage({ command: 'paste' }));\n    document.getElementById('cancelBtn').addEventListener('click', () => vscode.postMessage({ command: 'cancel' }));\n\n    let remaining = ${timeoutSec};\n    const timerEl = document.getElementById('timer');\n    const interval = setInterval(() => {\n      remaining--;\n      if (remaining <= 0) {\n        clearInterval(interval);\n        timerEl.textContent = 'Auto-cancelled';\n        vscode.postMessage({ command: 'timeout' });\n      } else {\n        timerEl.textContent = 'Auto-cancel in ' + remaining + 's';\n      }\n    }, 1000);\n  </script>\n</body>\n</html>`;\n}\n", "import * as vscode from 'vscode';\nimport * as path from 'path';\nimport type { ImageStore } from '../storage/imageStore';\nimport type { ClipboardFormat } from '../clipboard/types';\nimport type { PasteResult } from '../api';\nimport { convertImage, SaveFormat } from '../image/convert';\nimport { insertPathToTerminal } from '../terminal/insertPath';\nimport { detectPlatform } from '../platform/detect';\nimport { logger } from '../util/logger';\nimport { notify } from '../util/notify';\nimport { Mutex } from '../util/mutex';\n\nconst ACCEPTED_MIMES: Record<string, ClipboardFormat> = {\n  'image/png': 'png',\n  'image/jpeg': 'jpeg',\n  'image/gif': 'png', // will be treated as raw data, save as png\n  'image/bmp': 'bmp',\n  'image/webp': 'webp',\n  'image/svg+xml': 'png', // SVG saved as png fallback\n};\n\nconst MAX_FILE_SIZE = 50 * 1024 * 1024; // 50 MB\n\ninterface DroppedFile {\n  name: string;\n  data: string; // base64\n  mimeType: string;\n}\n\ninterface FilesDroppedMessage {\n  type: 'files-dropped';\n  files: DroppedFile[];\n}\n\ntype WebviewMessage = FilesDroppedMessage;\n\nexport class DropZoneProvider implements vscode.WebviewViewProvider {\n  private readonly _extensionUri: vscode.Uri;\n  private readonly _mutex: Mutex;\n\n  constructor(\n    extensionUri: vscode.Uri,\n    private readonly imageStore: ImageStore,\n    private readonly pasteEmitter: vscode.EventEmitter<PasteResult>,\n    mutex?: Mutex,\n  ) {\n    this._extensionUri = extensionUri;\n    this._mutex = mutex ?? new Mutex();\n  }\n\n  resolveWebviewView(\n    webviewView: vscode.WebviewView,\n    _context: vscode.WebviewViewResolveContext,\n    _token: vscode.CancellationToken,\n  ): void {\n    webviewView.webview.options = {\n      enableScripts: true,\n      localResourceRoots: [vscode.Uri.joinPath(this._extensionUri, 'media')],\n    };\n\n    webviewView.webview.html = this._getHtml(webviewView.webview);\n\n    webviewView.webview.onDidReceiveMessage((message: WebviewMessage) => {\n      this._handleMessage(message, webviewView.webview).catch((err) => {\n        logger.error('Drop zone: unhandled message error', err);\n      });\n    });\n  }\n\n  private async _handleMessage(\n    message: WebviewMessage,\n    webview: vscode.Webview,\n  ): Promise<void> {\n    if (message.type !== 'files-dropped') {\n      return;\n    }\n\n    const files = message.files;\n    if (!files || files.length === 0) {\n      return;\n    }\n\n    const release = await this._mutex.acquire();\n    try {\n      await this._processDroppedFiles(files, webview);\n    } finally {\n      release();\n    }\n  }\n\n  private async _processDroppedFiles(\n    files: DroppedFile[],\n    webview: vscode.Webview,\n  ): Promise<void> {\n    const config = vscode.workspace.getConfiguration('terminalImgPaste');\n    const saveFormat = config.get<SaveFormat>('saveFormat', 'auto');\n    const platform = detectPlatform();\n\n    for (const file of files) {\n      try {\n        // Validate MIME type\n        const format = ACCEPTED_MIMES[file.mimeType];\n        if (!format) {\n          webview.postMessage({\n            type: 'drop-result',\n            success: false,\n            message: `Unsupported file type: ${file.mimeType}`,\n          });\n          logger.warn(`Rejected drop: unsupported MIME type ${file.mimeType}`);\n          continue;\n        }\n\n        // Decode base64\n        const buffer = Buffer.from(file.data, 'base64');\n\n        // Validate size\n        if (buffer.length > MAX_FILE_SIZE) {\n          webview.postMessage({\n            type: 'drop-result',\n            success: false,\n            message: 'File too large (max 50 MB)',\n          });\n          logger.warn(`Rejected drop: file too large (${buffer.length} bytes)`);\n          continue;\n        }\n\n        if (buffer.length === 0) {\n          webview.postMessage({\n            type: 'drop-result',\n            success: false,\n            message: 'Empty file data',\n          });\n          continue;\n        }\n\n        // Apply format conversion if configured\n        const converted = await convertImage(buffer, format, saveFormat, platform);\n\n        // Save to image store\n        const filePath = await this.imageStore.save(converted.data, converted.format);\n\n        // Insert path to terminal\n        insertPathToTerminal(filePath);\n\n        // Fire the paste event\n        this.pasteEmitter.fire({ path: filePath, format: converted.format });\n\n        webview.postMessage({\n          type: 'drop-result',\n          success: true,\n          message: `Saved: ${path.basename(filePath)}`,\n        });\n\n        notify.statusBar('Image dropped and saved', 3000);\n        logger.info(`Drop zone: saved ${file.name} as ${filePath}`);\n      } catch (err) {\n        const errMsg = err instanceof Error ? err.message : String(err);\n        webview.postMessage({\n          type: 'drop-result',\n          success: false,\n          message: `Failed: ${errMsg}`,\n        });\n        logger.error(`Drop zone: failed to process ${file.name}`, err);\n      }\n    }\n  }\n\n  private _getHtml(webview: vscode.Webview): string {\n    const cssUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, 'media', 'dropZone.css'),\n    );\n    const jsUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, 'media', 'dropZone.js'),\n    );\n\n    return `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"Content-Security-Policy\"\n        content=\"default-src 'none'; style-src ${webview.cspSource}; script-src ${webview.cspSource};\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <link rel=\"stylesheet\" href=\"${cssUri}\">\n  <title>Drop Zone</title>\n</head>\n<body>\n  <div id=\"drop-zone\" class=\"drop-zone\">\n    <div class=\"drop-icon\">&#128247;</div>\n    <div class=\"drop-text\">Drop images here</div>\n  </div>\n  <div id=\"status\" class=\"status-message\"></div>\n  <script src=\"${jsUri}\"></script>\n</body>\n</html>`;\n  }\n}\n", "import * as vscode from 'vscode';\nimport { logger } from './logger';\n\nexport type NotificationLevel = 'all' | 'errors' | 'none';\n\nexport interface Notifier {\n  /** Show a success/info status bar message (suppressed at 'errors' and 'none'). */\n  statusBar(message: string, durationMs?: number): void;\n\n  /** Show an informational message popup (suppressed at 'errors' and 'none'). */\n  info(message: string): void;\n\n  /** Show a warning message popup (suppressed at 'errors' and 'none'). Returns the button choice or undefined. */\n  warning(message: string, ...buttons: string[]): Promise<string | undefined>;\n\n  /** Show an error message popup (suppressed at 'none'). Always logged to output channel. */\n  error(message: string): void;\n}\n\nfunction getLevel(): NotificationLevel {\n  return vscode.workspace\n    .getConfiguration('terminalImgPaste')\n    .get<NotificationLevel>('notifications', 'all');\n}\n\nexport function createNotifier(): Notifier {\n  return {\n    statusBar(message: string, durationMs = 3000): void {\n      logger.info(message);\n      if (getLevel() === 'all') {\n        vscode.window.setStatusBarMessage(message, durationMs);\n      }\n    },\n\n    info(message: string): void {\n      logger.info(message);\n      if (getLevel() === 'all') {\n        vscode.window.showInformationMessage(message);\n      }\n    },\n\n    async warning(message: string, ...buttons: string[]): Promise<string | undefined> {\n      logger.warn(message);\n      if (getLevel() === 'all') {\n        return vscode.window.showWarningMessage(message, ...buttons);\n      }\n      // When suppressed with action buttons, auto-approve (first button)\n      // so confirmation dialogs don't silently block operations.\n      return buttons.length > 0 ? buttons[0] : undefined;\n    },\n\n    error(message: string): void {\n      logger.error(message);\n      const level = getLevel();\n      if (level === 'all' || level === 'errors') {\n        vscode.window.showErrorMessage(message);\n      }\n    },\n  };\n}\n\nexport const notify: Notifier = createNotifier();\n", "/**\n * Simple async mutex for serializing operations.\n * Usage:\n *   const release = await mutex.acquire();\n *   try { ... } finally { release(); }\n */\nexport class Mutex {\n  private _queue: Array<() => void> = [];\n  private _locked = false;\n\n  acquire(): Promise<() => void> {\n    return new Promise<() => void>((resolve) => {\n      const tryAcquire = () => {\n        if (!this._locked) {\n          this._locked = true;\n          resolve(() => {\n            this._locked = false;\n            const next = this._queue.shift();\n            if (next) {\n              next();\n            }\n          });\n        } else {\n          this._queue.push(tryAcquire);\n        }\n      };\n      tryAcquire();\n    });\n  }\n}\n", "import * as path from 'path';\nimport * as vscode from 'vscode';\nimport type { PlatformInfo } from '../platform/detect';\nimport type { ClipboardReader } from '../clipboard/types';\nimport { FallbackClipboardReader } from '../clipboard/fallback';\nimport { detectRemoteContext } from '../platform/remote';\nimport { detectShellType } from '../terminal/shellDetect';\nimport { collectImagesRecursive } from '../storage/imageStore';\nimport { logger } from '../util/logger';\n\nexport interface DiagnosticReport {\n  platform: {\n    os: string;\n    isWsl: boolean;\n    wslVersion: string;\n    hasWslg: string;\n    displayServer: string;\n    powershellPath: string;\n  };\n  clipboard: {\n    readers: Array<{ name: string; available: string }>;\n    detectedFormat: string;\n  };\n  storage: {\n    workspaceFolder: string;\n    imageFolder: string;\n    imageCount: string;\n    organizeFolders: string;\n    filenamePattern: string;\n  };\n  settings: {\n    maxImages: number;\n    autoGitIgnore: boolean;\n    sendNewline: boolean;\n    showPreview: boolean;\n    notifications: string;\n    saveFormat: string;\n    folderName: string;\n    warnOnRemote: boolean;\n  };\n  terminal: {\n    activeShell: string;\n    isRemote: boolean;\n    remoteName: string;\n  };\n}\n\nasync function countImages(folder: string): Promise<number> {\n  return (await collectImagesRecursive(folder)).length;\n}\n\nexport async function gatherDiagnostics(\n  platform: PlatformInfo,\n  reader: ClipboardReader,\n): Promise<DiagnosticReport> {\n  const config = vscode.workspace.getConfiguration('terminalImgPaste');\n\n  // Platform info\n  const platformSection = {\n    os: platform.os,\n    isWsl: platform.isWSL,\n    wslVersion: platform.isWSL ? `WSL${platform.wslVersion ?? '?'}` : 'N/A',\n    hasWslg: platform.isWSL ? (platform.hasWslg ? 'Yes' : 'No') : 'N/A',\n    displayServer: platform.displayServer,\n    powershellPath: platform.powershellPath ?? 'N/A',\n  };\n\n  // Clipboard readers\n  const readerList = reader instanceof FallbackClipboardReader\n    ? [...reader.getReaders()]\n    : [reader];\n  const readers: Array<{ name: string; available: string }> = [];\n  for (const r of readerList) {\n    const name = r.constructor.name;\n    try {\n      const avail = await r.isToolAvailable();\n      readers.push({ name, available: avail ? 'Yes' : 'No' });\n    } catch (err) {\n      readers.push({ name, available: `Error: ${err instanceof Error ? err.message : String(err)}` });\n    }\n  }\n\n  let detectedFormat = 'N/A';\n  try {\n    detectedFormat = await reader.detectFormat();\n  } catch (err) {\n    detectedFormat = `Error: ${err instanceof Error ? err.message : String(err)}`;\n  }\n\n  // Storage\n  const folders = vscode.workspace.workspaceFolders;\n  const workspaceFolder = folders?.[0]?.uri.fsPath ?? 'None';\n  const folderName = config.get<string>('folderName', '.tip-images');\n  const imageFolder = folders ? path.join(workspaceFolder, folderName) : 'N/A';\n  const maxImages = config.get<number>('maxImages', 20);\n  const imageCount = folders ? await countImages(imageFolder) : 0;\n\n  // Terminal\n  const terminal = vscode.window.activeTerminal;\n  const activeShell = terminal ? detectShellType(terminal) : 'No active terminal';\n  const remoteCtx = detectRemoteContext();\n\n  return {\n    platform: platformSection,\n    clipboard: { readers, detectedFormat },\n    storage: {\n      workspaceFolder,\n      imageFolder,\n      imageCount: `${imageCount} / ${maxImages}`,\n      organizeFolders: config.get<string>('organizeFolders', 'flat'),\n      filenamePattern: config.get<string>('filenamePattern', 'img-{timestamp}'),\n    },\n    settings: {\n      maxImages,\n      autoGitIgnore: config.get<boolean>('autoGitIgnore', true),\n      sendNewline: config.get<boolean>('sendNewline', false),\n      showPreview: config.get<boolean>('showPreview', false),\n      notifications: config.get<string>('notifications', 'all'),\n      saveFormat: config.get<string>('saveFormat', 'auto'),\n      folderName,\n      warnOnRemote: config.get<boolean>('warnOnRemote', true),\n    },\n    terminal: {\n      activeShell,\n      isRemote: remoteCtx.remote,\n      remoteName: remoteCtx.remote ? remoteCtx.type : 'N/A',\n    },\n  };\n}\n\nexport function formatDiagnosticsMarkdown(report: DiagnosticReport): string {\n  const lines: string[] = [];\n  lines.push('# Terminal Image Paste \u2014 Diagnostics');\n  lines.push('');\n\n  // Platform\n  lines.push('## Platform');\n  lines.push('| Property | Value |');\n  lines.push('|----------|-------|');\n  lines.push(`| OS | ${report.platform.os} |`);\n  lines.push(`| WSL | ${report.platform.isWsl ? `Yes (${report.platform.wslVersion})` : 'No'} |`);\n  if (report.platform.isWsl) {\n    lines.push(`| WSLg | ${report.platform.hasWslg} |`);\n  }\n  lines.push(`| Display Server | ${report.platform.displayServer} |`);\n  if (report.platform.powershellPath !== 'N/A') {\n    lines.push(`| PowerShell Path | ${report.platform.powershellPath} |`);\n  }\n  lines.push('');\n\n  // Clipboard\n  lines.push('## Clipboard');\n  lines.push('| Reader | Available |');\n  lines.push('|--------|-----------|');\n  for (const r of report.clipboard.readers) {\n    lines.push(`| ${r.name} | ${r.available} |`);\n  }\n  lines.push(`| Detected Format | ${report.clipboard.detectedFormat} |`);\n  lines.push('');\n\n  // Storage\n  lines.push('## Storage');\n  lines.push('| Property | Value |');\n  lines.push('|----------|-------|');\n  lines.push(`| Workspace Folder | ${report.storage.workspaceFolder} |`);\n  lines.push(`| Image Folder | ${report.storage.imageFolder} |`);\n  lines.push(`| Image Count | ${report.storage.imageCount} |`);\n  lines.push(`| Organization | ${report.storage.organizeFolders} |`);\n  lines.push(`| Filename Pattern | ${report.storage.filenamePattern} |`);\n  lines.push('');\n\n  // Settings\n  lines.push('## Settings');\n  lines.push('| Setting | Value |');\n  lines.push('|---------|-------|');\n  lines.push(`| maxImages | ${report.settings.maxImages} |`);\n  lines.push(`| autoGitIgnore | ${report.settings.autoGitIgnore} |`);\n  lines.push(`| sendNewline | ${report.settings.sendNewline} |`);\n  lines.push(`| showPreview | ${report.settings.showPreview} |`);\n  lines.push(`| notifications | ${report.settings.notifications} |`);\n  lines.push(`| saveFormat | ${report.settings.saveFormat} |`);\n  lines.push(`| warnOnRemote | ${report.settings.warnOnRemote} |`);\n  lines.push('');\n\n  // Terminal\n  lines.push('## Terminal');\n  lines.push('| Property | Value |');\n  lines.push('|----------|-------|');\n  lines.push(`| Active Shell | ${report.terminal.activeShell} |`);\n  lines.push(`| Remote | ${report.terminal.isRemote ? 'Yes' : 'No'} |`);\n  if (report.terminal.isRemote) {\n    lines.push(`| Remote Name | ${report.terminal.remoteName} |`);\n  }\n  lines.push('');\n\n  lines.push('---');\n  lines.push(`*Generated at ${new Date().toISOString()}*`);\n  lines.push('');\n\n  return lines.join('\\n');\n}\n\nexport async function runDiagnostics(\n  platform: PlatformInfo,\n  reader: ClipboardReader,\n): Promise<void> {\n  try {\n    const report = await gatherDiagnostics(platform, reader);\n    const content = formatDiagnosticsMarkdown(report);\n    const doc = await vscode.workspace.openTextDocument({ content, language: 'markdown' });\n    await vscode.window.showTextDocument(doc);\n    logger.info('Diagnostics report generated');\n  } catch (err) {\n    const message = err instanceof Error ? err.message : String(err);\n    logger.error('Failed to generate diagnostics report', err);\n    vscode.window.showErrorMessage(`Terminal Image Paste: Failed to generate diagnostics \u2014 ${message}`);\n  }\n}\n", "import * as vscode from 'vscode';\nimport * as path from 'path';\nimport type { ClipboardReader } from './clipboard/types';\nimport type { ImageStore } from './storage/imageStore';\nimport type { PlatformInfo } from './platform/detect';\nimport { convertImage, SaveFormat } from './image/convert';\nimport { insertPathToTerminal } from './terminal/insertPath';\nexport interface PasteResult {\n  /** Absolute path to the saved image file */\n  path: string;\n  /** Detected or converted format */\n  format: string;\n}\n\nexport interface TerminalImgPasteApi {\n  /**\n   * Read the clipboard image, save it to the image folder, and return the path.\n   * Does NOT insert the path into a terminal \u2014 the caller decides what to do with it.\n   * Returns undefined if no image is on the clipboard.\n   */\n  pasteFromClipboard(): Promise<PasteResult | undefined>;\n\n  /**\n   * Send a file path to the active terminal.\n   * Uses shell-aware quoting based on the active terminal's shell type.\n   */\n  sendPathToTerminal(filePath: string): void;\n\n  /**\n   * Get the absolute path to the image storage folder for the current workspace.\n   * Returns undefined if no workspace is open.\n   */\n  getImageFolder(): string | undefined;\n\n  /**\n   * Event fired after every successful image paste (clipboard \u2192 file).\n   * Consumers can subscribe to react to paste events.\n   */\n  onImagePasted: vscode.Event<PasteResult>;\n}\n\nexport function createApi(\n  platform: PlatformInfo,\n  reader: ClipboardReader,\n  imageStore: ImageStore,\n  emitter: vscode.EventEmitter<PasteResult>,\n): TerminalImgPasteApi {\n  return {\n    async pasteFromClipboard(): Promise<PasteResult | undefined> {\n      const hasImage = await reader.hasImage();\n      if (!hasImage) {\n        return undefined;\n      }\n\n      const { data, format } = await reader.readImage();\n\n      const config = vscode.workspace.getConfiguration('terminalImgPaste');\n      const saveFormat = config.get<SaveFormat>('saveFormat', 'auto');\n      const converted = await convertImage(data, format, saveFormat, platform);\n\n      const filePath = await imageStore.save(converted.data, converted.format);\n\n      const result: PasteResult = { path: filePath, format: converted.format };\n      emitter.fire(result);\n      return result;\n    },\n\n    sendPathToTerminal(filePath: string): void {\n      insertPathToTerminal(filePath);\n    },\n\n    getImageFolder(): string | undefined {\n      const folders = vscode.workspace.workspaceFolders;\n      if (!folders || folders.length === 0) {\n        return undefined;\n      }\n      const config = vscode.workspace.getConfiguration('terminalImgPaste');\n      const folderName = config.get<string>('folderName', '.tip-images');\n      return path.resolve(folders[0].uri.fsPath, folderName);\n    },\n\n    onImagePasted: emitter.event,\n  };\n}\n"],
  "mappings": "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",
  "names": ["extension_exports", "__export", "activate", "deactivate", "__toCommonJS", "vscode", "fs", "import_child_process", "cached", "detectOS", "readProcVersion", "detectWSL", "procVersion", "detectWslVersion", "detectWslg", "detectDisplayServer", "os", "isWSL", "sessionType", "whichSync", "name", "detectPowershellPath", "candidates", "candidate", "fromPath", "detectPlatform", "wslVersion", "hasWslg", "displayServer", "powershellPath", "vscode", "detectRemoteContext", "remoteName", "import_child_process", "DEFAULT_TIMEOUT", "DEFAULT_MAX_BUFFER", "DEFAULT_MAX_BUFFER_BINARY", "exitCode", "error", "exec", "command", "args", "options", "resolve", "reject", "stdout", "stderr", "execBuffer", "execBufferWithStdin", "stderrStr", "timeout", "maxBuffer", "child", "stdoutChunks", "stderrChunks", "stdoutLen", "stderrLen", "finished", "timer", "chunk", "err", "code", "import_child_process", "vscode", "timestamp", "now", "h", "m", "s", "ms", "createLogger", "name", "channel", "message", "err", "line", "logger", "cache", "isWindows", "resolveToolPath", "toolName", "cached", "resolver", "resolved", "resolve", "reject", "error", "stdout", "firstLine", "logger", "resolveToolPathOrFallback", "getClipboardInfo", "stdout", "exec", "parseClipboardFormats", "info", "formats", "MacosClipboardReader", "resolveToolPathOrFallback", "pngpaste", "execBuffer", "FORMAT_TO_OSASCRIPT_CLASS", "MacosOsascriptClipboardReader", "info", "getClipboardInfo", "parseClipboardFormats", "formats", "format", "hasNativeClass", "osClass", "resolvedFormat", "stdout", "execBuffer", "MIME_FORMAT_MAP", "detectFormatFromMimeTypes", "mimeList", "mime", "format", "detectMimeAndFormat", "LinuxClipboardReader", "displayServer", "resolveToolPathOrFallback", "exec", "tool", "stdout", "types", "detected", "resolvedFormat", "execBuffer", "fs", "encodePowerShellCommand", "script", "PS_HAS_IMAGE", "PS_READ_IMAGE", "PowerShellClipboardReader", "exec", "encodePowerShellCommand", "tempPath", "err", "localPath", "logger", "WindowsClipboardReader", "PowerShellClipboardReader", "resolveToolPathOrFallback", "windowsPath", "WslClipboardReader", "PowerShellClipboardReader", "platform", "windowsPath", "exec", "err", "FallbackClipboardReader", "readers", "r", "reader", "err", "logger", "errors", "e", "fs", "path", "EXT_FORMAT_MAP", "fileUriToPath", "uri", "parsed", "FilePathClipboardReader", "paths", "p", "ext", "format", "found", "LinuxFilePathReader", "displayServer", "tool", "exec", "stdout", "line", "PS_GET_FILE_DROP_LIST", "WindowsFilePathReader", "encodePowerShellCommand", "WslFilePathReader", "platform", "windowsPaths", "wslPaths", "winPath", "wslPath", "err", "logger", "MacosFilePathReader", "trimmed", "createClipboardReader", "platform", "hasDisplayServer", "FallbackClipboardReader", "LinuxClipboardReader", "WslClipboardReader", "LinuxFilePathReader", "WslFilePathReader", "readers", "MacosClipboardReader", "MacosOsascriptClipboardReader", "MacosFilePathReader", "WindowsClipboardReader", "WindowsFilePathReader", "primary", "fallbackDS", "fallback", "crypto", "fs", "path", "vscode", "fs", "path", "MAX_COLLISION_RETRIES", "writeSecureFile", "filePath", "data", "err", "ext", "base", "i", "candidate", "DEFAULT_FOLDER_NAME", "IMAGE_EXTENSIONS", "formatToExtension", "format", "PNG_SIGNATURE", "validateImage", "buffer", "logger", "getConfig", "getWorkspaceRoot", "folders", "getFolderName", "getImageFolderPath", "root", "folderName", "resolved", "DEFAULT_FILENAME_PATTERN", "UNIQUENESS_PLACEHOLDERS", "resolveFilenamePattern", "pattern", "imageBuffer", "existingFiles", "now", "p", "ts", "formatTimestamp", "result", "formatDate", "formatTime", "hash", "resolveSequentialNumber", "ms", "y", "mo", "d", "h", "mi", "s", "escaped", "regex", "maxN", "file", "match", "num", "generateFileName", "baseName", "ext", "assertInsideWorkspace", "target", "realTarget", "realRoot", "caseInsensitive", "normTarget", "normRoot", "getSubdirectory", "organize", "collectImagesRecursive", "folder", "results", "entries", "entry", "fullPath", "removeEmptyDirs", "dir", "rootFolder", "err", "createImageStore", "subdir", "saveFolder", "fileName", "requestedPath", "filePath", "writeSecureFile", "config", "rawMaxImages", "maxImages", "imageFiles", "f", "toDelete", "allImages", "a", "b", "affectedDirs", "img", "workspaceRoot", "gitignorePath", "content", "line", "suffix", "vscode", "path", "shellPatterns", "matchShell", "shellPath", "base", "pattern", "type", "detectShellType", "terminal", "envShell", "quotePath", "filePath", "shell", "insertPathToTerminal", "terminal", "shellType", "detectShellType", "text", "addNewline", "logger", "fs", "os", "path", "convertImage", "data", "sourceFormat", "targetFormat", "platform", "convertWithPlatformTool", "err", "logger", "findConversionTool", "exec", "tool", "convertWithSips", "convertWithMagick", "convertWithFfmpeg", "convertWithPowershell", "tmpDir", "inputPath", "targetExt", "outputPath", "actualInputPath", "writeSecureFile", "inputSpec", "outputSpec", "execBuffer", "powershellPath", "encodePowerShellCommand", "vscode", "TIMEOUT_MS", "showImagePreview", "imageData", "format", "resolve", "resolved", "timer", "finish", "value", "panel", "mimeType", "base64", "buildHtml", "msg", "timeoutMs", "timeoutSec", "vscode", "path", "vscode", "getLevel", "createNotifier", "message", "durationMs", "logger", "buttons", "level", "notify", "Mutex", "resolve", "tryAcquire", "next", "ACCEPTED_MIMES", "MAX_FILE_SIZE", "DropZoneProvider", "extensionUri", "imageStore", "pasteEmitter", "mutex", "Mutex", "webviewView", "_context", "_token", "message", "err", "logger", "webview", "files", "release", "saveFormat", "platform", "detectPlatform", "file", "format", "buffer", "converted", "convertImage", "filePath", "insertPathToTerminal", "notify", "errMsg", "cssUri", "jsUri", "path", "vscode", "countImages", "folder", "collectImagesRecursive", "gatherDiagnostics", "platform", "reader", "config", "platformSection", "readerList", "FallbackClipboardReader", "readers", "r", "name", "avail", "err", "detectedFormat", "folders", "workspaceFolder", "folderName", "imageFolder", "maxImages", "imageCount", "terminal", "activeShell", "detectShellType", "remoteCtx", "detectRemoteContext", "formatDiagnosticsMarkdown", "report", "lines", "runDiagnostics", "content", "doc", "logger", "message", "vscode", "path", "createApi", "platform", "reader", "imageStore", "emitter", "data", "format", "saveFormat", "converted", "convertImage", "result", "filePath", "insertPathToTerminal", "folders", "folderName", "handleCommandError", "commandName", "err", "message", "notify", "logger", "activate", "context", "platform", "detectPlatform", "reader", "createClipboardReader", "imageStore", "createImageStore", "pasteEmitter", "available", "pasteMutex", "Mutex", "pasteImageDisposable", "release", "config", "remoteCtx", "detectRemoteContext", "data", "format", "showImagePreview", "saveFormat", "converted", "convertImage", "filePath", "insertPathToTerminal", "sendPathDisposable", "uri", "diagnosticsDisposable", "runDiagnostics", "viewId", "provider", "DropZoneProvider", "createApi", "deactivate"]
}
