{
  "version": 3,
  "sources": ["../src/extension.ts", "../src/platform/detect.ts", "../src/platform/remote.ts", "../src/util/exec.ts", "../src/util/toolPath.ts", "../src/util/logger.ts", "../src/clipboard/macosClipboard.ts", "../src/clipboard/macosOsascriptClipboard.ts", "../src/clipboard/linuxClipboard.ts", "../src/clipboard/powershellClipboard.ts", "../src/util/powershell.ts", "../src/clipboard/windowsClipboard.ts", "../src/clipboard/wslClipboard.ts", "../src/clipboard/fallback.ts", "../src/clipboard/index.ts", "../src/storage/imageStore.ts", "../src/util/fs.ts", "../src/terminal/insertPath.ts", "../src/terminal/shellDetect.ts", "../src/image/convert.ts", "../src/util/mutex.ts"],
  "sourcesContent": ["import * as vscode from 'vscode';\nimport { detectPlatform } from './platform/detect';\nimport { detectRemoteContext } from './platform/remote';\nimport { createClipboardReader, ClipboardReader } from './clipboard/index';\nimport { createImageStore, ImageStore } from './storage/imageStore';\nimport { insertPathToTerminal } from './terminal/insertPath';\nimport { convertImage, SaveFormat } from './image/convert';\nimport { logger } from './util/logger';\nimport { Mutex } from './util/mutex';\n\nfunction handleCommandError(commandName: string, err: unknown): void {\n  const message = err instanceof Error ? err.message : String(err);\n  vscode.window.showErrorMessage(`Terminal Image Paste: ${message}`);\n  logger.error(`${commandName} command failed`, err);\n}\n\nexport function activate(context: vscode.ExtensionContext): void {\n  const platform = detectPlatform();\n  const reader: ClipboardReader = createClipboardReader(platform);\n  const imageStore: ImageStore = createImageStore();\n\n  // Check tool availability at activation \u2014 warn but don't block\n  reader.isToolAvailable().then((available) => {\n    if (!available) {\n      vscode.window.showWarningMessage(\n        `Terminal Image Paste: clipboard tool \"${reader.requiredTool()}\" not found. ` +\n          `Install it to use clipboard image pasting.`,\n      );\n    }\n  }).catch((err) => {\n    logger.error('Failed to check tool availability', err);\n  });\n\n  const pasteMutex = new Mutex();\n\n  const pasteImageDisposable = vscode.commands.registerCommand(\n    'terminalImgPaste.pasteImage',\n    async () => {\n      const release = await pasteMutex.acquire();\n      try {\n        const toolAvailable = await reader.isToolAvailable();\n        if (!toolAvailable) {\n          vscode.window.showWarningMessage(\n            `Terminal Image Paste: \"${reader.requiredTool()}\" is not installed. ` +\n              `Please install it to paste clipboard images.`,\n          );\n          return;\n        }\n\n        const config = vscode.workspace.getConfiguration('terminalImgPaste');\n        const warnOnRemote = config.get<boolean>('warnOnRemote', true);\n\n        if (warnOnRemote) {\n          const remoteCtx = detectRemoteContext();\n          if (remoteCtx.remote && remoteCtx.type !== 'wsl') {\n            const choice = await vscode.window.showWarningMessage(\n              'Clipboard images are saved locally. The pasted path may not be accessible from the remote terminal.',\n              'Paste Anyway',\n              'Cancel',\n            );\n            if (choice !== 'Paste Anyway') {\n              return;\n            }\n          }\n        }\n\n        const hasImage = await reader.hasImage();\n        if (!hasImage) {\n          vscode.window.showInformationMessage('No image found in clipboard.');\n          return;\n        }\n\n        const { data, format } = await reader.readImage();\n\n        const saveFormat = config.get<SaveFormat>('saveFormat', 'auto');\n        const converted = await convertImage(data, format, saveFormat, platform);\n\n        const filePath = await imageStore.save(converted.data, converted.format);\n        insertPathToTerminal(filePath);\n\n        vscode.window.setStatusBarMessage('Image pasted to terminal', 3000);\n      } catch (err) {\n        handleCommandError('pasteImage', err);\n      } finally {\n        release();\n      }\n    },\n  );\n\n  const sendPathDisposable = vscode.commands.registerCommand(\n    'terminalImgPaste.sendPathToTerminal',\n    async (uri: vscode.Uri) => {\n      try {\n        if (!uri?.fsPath) {\n          vscode.window.showErrorMessage(\n            'Terminal Image Paste: No file selected.',\n          );\n          return;\n        }\n\n        insertPathToTerminal(uri.fsPath);\n        vscode.window.setStatusBarMessage('Path sent to terminal', 3000);\n      } catch (err) {\n        handleCommandError('sendPathToTerminal', err);\n      }\n    },\n  );\n\n  context.subscriptions.push(pasteImageDisposable, sendPathDisposable);\n  logger.info(`Extension activated (platform: ${platform.os}, WSL: ${platform.isWSL})`);\n}\n\nexport function deactivate(): void {\n  logger.info('Extension deactivating');\n}\n", "import * as fs from \"fs\";\nimport { execFileSync } from \"child_process\";\n\nexport interface PlatformInfo {\n  os: \"macos\" | \"linux\" | \"windows\";\n  isWSL: boolean;\n  wslVersion: 1 | 2 | null;\n  hasWslg: boolean;\n  displayServer: \"x11\" | \"wayland\" | \"unknown\";\n  powershellPath: string | null;\n}\n\nlet cached: PlatformInfo | null = null;\n\nfunction detectOS(): PlatformInfo[\"os\"] {\n  switch (process.platform) {\n    case \"darwin\":\n      return \"macos\";\n    case \"win32\":\n      return \"windows\";\n    default:\n      return \"linux\";\n  }\n}\n\nfunction readProcVersion(): string | null {\n  try {\n    return fs.readFileSync(\"/proc/version\", \"utf-8\");\n  } catch {\n    return null;\n  }\n}\n\nfunction detectWSL(procVersion: string | null): boolean {\n  if (!procVersion) {\n    return false;\n  }\n  return /microsoft/i.test(procVersion);\n}\n\nfunction detectWslVersion(procVersion: string | null): 1 | 2 | null {\n  if (!procVersion || !detectWSL(procVersion)) {\n    return null;\n  }\n  // WSL2 kernels contain \"microsoft-standard-WSL2\"\n  if (/microsoft-standard-WSL2/i.test(procVersion)) {\n    return 2;\n  }\n  // WSL1 kernels contain \"Microsoft\" but not \"microsoft-standard-WSL2\"\n  return 1;\n}\n\nfunction detectWslg(): boolean {\n  return fs.existsSync(\"/mnt/wslg/\");\n}\n\nfunction detectDisplayServer(\n  os: PlatformInfo[\"os\"],\n  isWSL: boolean\n): PlatformInfo[\"displayServer\"] {\n  if (os !== \"linux\") {\n    return \"unknown\";\n  }\n\n  // For WSL, check for WSLg (which provides X11/Wayland via /mnt/wslg/)\n  if (isWSL) {\n    if (process.env.WAYLAND_DISPLAY) {\n      return \"wayland\";\n    }\n    if (process.env.DISPLAY) {\n      return \"x11\";\n    }\n    return \"unknown\";\n  }\n\n  const sessionType = process.env.XDG_SESSION_TYPE;\n\n  if (sessionType === \"wayland\") {\n    return \"wayland\";\n  }\n  if (sessionType === \"x11\") {\n    return \"x11\";\n  }\n\n  // Fallback: WAYLAND_DISPLAY is set by Wayland compositors even when\n  // XDG_SESSION_TYPE is absent (containers, some desktop environments, etc.)\n  if (process.env.WAYLAND_DISPLAY) {\n    return \"wayland\";\n  }\n\n  return \"unknown\";\n}\n\nfunction whichSync(name: string): string | null {\n  try {\n    return execFileSync(\"command\", [\"-v\", name], {\n      encoding: \"utf-8\",\n      timeout: 5000,\n      shell: true,\n    }).trim() || null;\n  } catch {\n    return null;\n  }\n}\n\nfunction detectPowershellPath(\n  os: PlatformInfo[\"os\"],\n  isWSL: boolean\n): string | null {\n  if (os === \"windows\") {\n    return \"powershell.exe\";\n  }\n\n  if (isWSL) {\n    // 1. Check well-known filesystem paths (fast, no subprocess)\n    const candidates = [\n      \"/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe\",\n      \"/mnt/c/Program Files/PowerShell/7/pwsh.exe\",\n    ];\n\n    for (const candidate of candidates) {\n      if (fs.existsSync(candidate)) {\n        return candidate;\n      }\n    }\n\n    // 2. Try PATH-based discovery (handles non-standard mount points)\n    const fromPath =\n      whichSync(\"powershell.exe\") ?? whichSync(\"pwsh.exe\");\n    if (fromPath) {\n      return fromPath;\n    }\n\n    // 3. Last resort: rely on WSL interop PATH\n    return \"powershell.exe\";\n  }\n\n  return null;\n}\n\nexport function detectPlatform(): PlatformInfo {\n  if (cached) {\n    return cached;\n  }\n\n  const os = detectOS();\n  const procVersion = os === \"linux\" ? readProcVersion() : null;\n  const isWSL = os === \"linux\" ? detectWSL(procVersion) : false;\n  const wslVersion = isWSL ? detectWslVersion(procVersion) : null;\n  const hasWslg = isWSL ? detectWslg() : false;\n  const displayServer = detectDisplayServer(os, isWSL);\n  const powershellPath = detectPowershellPath(os, isWSL);\n\n  cached = { os, isWSL, wslVersion, hasWslg, displayServer, powershellPath };\n  return cached;\n}\n", "import * as vscode from 'vscode';\n\nexport type RemoteContext =\n  | { remote: false }\n  | { remote: true; type: 'ssh-remote' | 'dev-container' | 'wsl' | 'tunnel' | 'codespaces' | string };\n\nexport function detectRemoteContext(): RemoteContext {\n  const remoteName = vscode.env.remoteName;\n\n  if (!remoteName) {\n    return { remote: false };\n  }\n\n  return { remote: true, type: remoteName };\n}\n", "import { execFile, spawn } from \"child_process\";\n\nconst DEFAULT_TIMEOUT = 10_000;\nconst DEFAULT_MAX_BUFFER = 10 * 1024 * 1024; // 10 MB\nconst DEFAULT_MAX_BUFFER_BINARY = 50 * 1024 * 1024; // 50 MB\n\nfunction exitCode(error: Error): string | number {\n  if (\"code\" in error && typeof error.code === \"number\") {\n    return error.code;\n  }\n  return (error as NodeJS.ErrnoException).code ?? \"unknown\";\n}\n\nexport interface ExecOptions {\n  timeout?: number;\n  cwd?: string;\n  maxBuffer?: number;\n  input?: Buffer;\n}\n\nexport interface ExecResult {\n  stdout: string;\n  stderr: string;\n}\n\nexport interface ExecBufferResult {\n  stdout: Buffer;\n  stderr: string;\n}\n\n/**\n * Execute a command with arguments, returning stdout and stderr as strings.\n * Uses `execFile` (no shell) to avoid shell-injection vulnerabilities.\n */\nexport function exec(\n  command: string,\n  args: string[],\n  options?: ExecOptions,\n): Promise<ExecResult> {\n  return new Promise((resolve, reject) => {\n    execFile(\n      command,\n      args,\n      {\n        encoding: \"utf-8\",\n        timeout: options?.timeout ?? DEFAULT_TIMEOUT,\n        maxBuffer: options?.maxBuffer ?? DEFAULT_MAX_BUFFER,\n        cwd: options?.cwd,\n      },\n      (error, stdout, stderr) => {\n        if (error) {\n          reject(\n            new Error(\n              `Command \"${command}\" failed (exit code ${exitCode(error)}): ${stderr || error.message}`,\n            ),\n          );\n          return;\n        }\n        resolve({ stdout, stderr });\n      },\n    );\n  });\n}\n\n/**\n * Execute a command with arguments, returning stdout as a raw Buffer and\n * stderr as a string.  Useful for reading binary data (e.g. clipboard\n * images) from tools that write to stdout.\n *\n * Uses `execFile` (no shell) to avoid shell-injection vulnerabilities.\n * When `options.input` is provided, uses `spawn` to pipe data to stdin.\n */\nexport function execBuffer(\n  command: string,\n  args: string[],\n  options?: ExecOptions,\n): Promise<ExecBufferResult> {\n  if (options?.input) {\n    return execBufferWithStdin(command, args, options);\n  }\n\n  return new Promise((resolve, reject) => {\n    execFile(\n      command,\n      args,\n      {\n        encoding: \"buffer\",\n        timeout: options?.timeout ?? DEFAULT_TIMEOUT,\n        maxBuffer: options?.maxBuffer ?? DEFAULT_MAX_BUFFER_BINARY,\n        cwd: options?.cwd,\n      },\n      (error, stdout, stderr) => {\n        // stderr comes back as a Buffer when encoding is \"buffer\"\n        const stderrStr =\n          stderr instanceof Buffer ? stderr.toString(\"utf-8\") : String(stderr);\n        if (error) {\n          reject(\n            new Error(\n              `Command \"${command}\" failed (exit code ${exitCode(error)}): ${stderrStr || error.message}`,\n            ),\n          );\n          return;\n        }\n        resolve({ stdout, stderr: stderrStr });\n      },\n    );\n  });\n}\n\n/**\n * Internal helper: execute a command with stdin data piped to it.\n * Uses `spawn` (no shell) to pipe input data to the child process's stdin.\n */\nfunction execBufferWithStdin(\n  command: string,\n  args: string[],\n  options: ExecOptions & { input: Buffer },\n): Promise<ExecBufferResult> {\n  const timeout = options.timeout ?? DEFAULT_TIMEOUT;\n  const maxBuffer = options.maxBuffer ?? DEFAULT_MAX_BUFFER_BINARY;\n\n  return new Promise((resolve, reject) => {\n    const child = spawn(command, args, {\n      stdio: [\"pipe\", \"pipe\", \"pipe\"],\n      cwd: options.cwd,\n    });\n\n    const stdoutChunks: Buffer[] = [];\n    const stderrChunks: Buffer[] = [];\n    let stdoutLen = 0;\n    let stderrLen = 0;\n    let finished = false;\n\n    const timer = setTimeout(() => {\n      if (!finished) {\n        finished = true;\n        child.kill(\"SIGTERM\");\n        reject(\n          new Error(\n            `Command \"${command}\" failed (exit code ETIMEDOUT): timed out after ${timeout}ms`,\n          ),\n        );\n      }\n    }, timeout);\n\n    child.stdout!.on(\"data\", (chunk: Buffer) => {\n      stdoutLen += chunk.length;\n      if (stdoutLen > maxBuffer) {\n        if (!finished) {\n          finished = true;\n          clearTimeout(timer);\n          child.kill(\"SIGTERM\");\n          reject(\n            new Error(\n              `Command \"${command}\" failed (exit code ERR_CHILD_PROCESS_STDIO_MAXBUFFER): stdout maxBuffer length exceeded`,\n            ),\n          );\n        }\n        return;\n      }\n      stdoutChunks.push(chunk);\n    });\n\n    child.stderr!.on(\"data\", (chunk: Buffer) => {\n      stderrLen += chunk.length;\n      if (stderrLen <= maxBuffer) {\n        stderrChunks.push(chunk);\n      }\n    });\n\n    child.on(\"error\", (err: Error) => {\n      if (!finished) {\n        finished = true;\n        clearTimeout(timer);\n        reject(\n          new Error(\n            `Command \"${command}\" failed (exit code ${exitCode(err)}): ${err.message}`,\n          ),\n        );\n      }\n    });\n\n    child.on(\"close\", (code: number | null) => {\n      if (finished) {\n        return;\n      }\n      finished = true;\n      clearTimeout(timer);\n\n      const stderrStr = Buffer.concat(stderrChunks).toString(\"utf-8\");\n      if (code !== 0) {\n        reject(\n          new Error(\n            `Command \"${command}\" failed (exit code ${code ?? \"unknown\"}): ${stderrStr || `process exited with code ${code}`}`,\n          ),\n        );\n        return;\n      }\n      resolve({\n        stdout: Buffer.concat(stdoutChunks),\n        stderr: stderrStr,\n      });\n    });\n\n    // Ignore EPIPE errors on stdin (child may exit before consuming all input)\n    child.stdin!.on(\"error\", () => {});\n    // Write input to stdin and close it\n    child.stdin!.end(options.input);\n  });\n}\n", "import { execFile } from 'child_process';\nimport { logger } from './logger';\n\nconst cache = new Map<string, string>();\n\nconst isWindows = process.platform === 'win32';\n\n/**\n * Resolves a tool name to its absolute path using `which` (Unix) or `where` (Windows).\n * Caches the result for subsequent calls.\n * Returns undefined if the tool is not found.\n */\nexport async function resolveToolPath(toolName: string): Promise<string | undefined> {\n  const cached = cache.get(toolName);\n  if (cached !== undefined) {\n    return cached;\n  }\n\n  const resolver = isWindows ? 'where' : 'which';\n  try {\n    const resolved = await new Promise<string>((resolve, reject) => {\n      execFile(resolver, [toolName], { timeout: 5000 }, (error, stdout) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        // `where` on Windows may return multiple lines; take the first\n        const firstLine = stdout.trim().split(/\\r?\\n/)[0];\n        resolve(firstLine);\n      });\n    });\n    cache.set(toolName, resolved);\n    return resolved;\n  } catch {\n    logger.warn(`Could not resolve absolute path for \"${toolName}\" \u2014 using bare name`);\n    return undefined;\n  }\n}\n\n/**\n * Resolve a tool name, returning the absolute path if found or the original name as fallback.\n */\nexport async function resolveToolPathOrFallback(toolName: string): Promise<string> {\n  return (await resolveToolPath(toolName)) ?? toolName;\n}\n\n/** Clear the resolved tool path cache (useful for testing). */\nexport function clearToolPathCache(): void {\n  cache.clear();\n}\n", "import * as vscode from 'vscode';\n\nexport interface Logger {\n  info(message: string): void;\n  warn(message: string, err?: unknown): void;\n  error(message: string, err?: unknown): void;\n  show(): void;\n}\n\nfunction timestamp(): string {\n  const now = new Date();\n  const h = String(now.getHours()).padStart(2, '0');\n  const m = String(now.getMinutes()).padStart(2, '0');\n  const s = String(now.getSeconds()).padStart(2, '0');\n  const ms = String(now.getMilliseconds()).padStart(3, '0');\n  return `[${h}:${m}:${s}.${ms}]`;\n}\n\nexport function createLogger(name: string): Logger {\n  const channel = vscode.window.createOutputChannel(name);\n\n  return {\n    info(message: string): void {\n      channel.appendLine(`${timestamp()} [INFO] ${message}`);\n    },\n\n    warn(message: string, err?: unknown): void {\n      let line = `${timestamp()} [WARN] ${message}`;\n      if (err !== undefined) {\n        if (err instanceof Error && err.stack) {\n          line += `\\n${err.stack}`;\n        } else {\n          line += `\\n${String(err)}`;\n        }\n      }\n      channel.appendLine(line);\n    },\n\n    error(message: string, err?: unknown): void {\n      let line = `${timestamp()} [ERROR] ${message}`;\n      if (err !== undefined) {\n        if (err instanceof Error && err.stack) {\n          line += `\\n${err.stack}`;\n        } else {\n          line += `\\n${String(err)}`;\n        }\n      }\n      channel.appendLine(line);\n    },\n\n    show(): void {\n      channel.show();\n    },\n  };\n}\n\nexport const logger: Logger = createLogger('Terminal Image Paste');\n", "import { ClipboardReader, ClipboardFormat, ClipboardImageResult } from \"./types\";\nimport { exec, execBuffer } from \"../util/exec\";\nimport { resolveToolPathOrFallback } from \"../util/toolPath\";\n\n/** Fetch raw clipboard info string from osascript (shared by macOS readers). */\nexport async function getClipboardInfo(): Promise<string> {\n  const { stdout } = await exec(\"osascript\", [\"-e\", \"clipboard info\"]);\n  return stdout;\n}\n\n/** Parse macOS `clipboard info` output and return detected formats in preference order. */\nexport function parseClipboardFormats(info: string): ClipboardFormat[] {\n  const formats: ClipboardFormat[] = [];\n  if (info.includes(\"\u00ABclass PNGf\u00BB\")) {\n    formats.push(\"png\");\n  }\n  if (info.includes(\"\u00ABclass JPEG\u00BB\") || info.includes(\"\u00ABclass JPEf\u00BB\")) {\n    formats.push(\"jpeg\");\n  }\n  if (info.includes(\"\u00ABclass TIFF\u00BB\")) {\n    formats.push(\"tiff\");\n  }\n  if (info.includes(\"\u00ABclass BMP \u00BB\") || info.includes(\"\u00ABclass BMPf\u00BB\")) {\n    formats.push(\"bmp\");\n  }\n  return formats;\n}\n\nexport class MacosClipboardReader implements ClipboardReader {\n  private resolvedPngpastePath: string | undefined;\n\n  private async getPngpastePath(): Promise<string> {\n    if (this.resolvedPngpastePath === undefined) {\n      this.resolvedPngpastePath = await resolveToolPathOrFallback(\"pngpaste\");\n    }\n    return this.resolvedPngpastePath;\n  }\n\n  requiredTool(): string {\n    return \"pngpaste\";\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    try {\n      await exec(\"which\", [\"pngpaste\"]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async hasImage(): Promise<boolean> {\n    try {\n      const info = await getClipboardInfo();\n      return parseClipboardFormats(info).length > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  async detectFormat(): Promise<ClipboardFormat> {\n    const info = await getClipboardInfo();\n    const formats = parseClipboardFormats(info);\n    if (formats.length > 0) {\n      return formats[0];\n    }\n    throw new Error(\"No image found in clipboard\");\n  }\n\n  async readImage(): Promise<ClipboardImageResult> {\n    const imageAvailable = await this.hasImage();\n    if (!imageAvailable) {\n      throw new Error(\"No image found in clipboard\");\n    }\n    const pngpaste = await this.getPngpastePath();\n    const { stdout } = await execBuffer(pngpaste, [\"-\"]);\n    return { data: stdout, format: \"png\" };\n  }\n}\n", "import { ClipboardReader, ClipboardFormat, ClipboardImageResult } from \"./types\";\nimport { execBuffer } from \"../util/exec\";\nimport { getClipboardInfo, parseClipboardFormats } from \"./macosClipboard\";\n\n/** Map from ClipboardFormat to the osascript class name used for clipboard coercion. */\nconst FORMAT_TO_OSASCRIPT_CLASS: Record<string, string> = {\n  png: \"PNGf\",\n  jpeg: \"JPEG\",\n  tiff: \"TIFF\",\n};\n\n/**\n * macOS clipboard reader using only osascript.\n * Used as a fallback when pngpaste is not installed.\n */\nexport class MacosOsascriptClipboardReader implements ClipboardReader {\n  requiredTool(): string {\n    return \"osascript (built-in)\";\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    return process.platform === \"darwin\";\n  }\n\n  async hasImage(): Promise<boolean> {\n    try {\n      const info = await getClipboardInfo();\n      return parseClipboardFormats(info).length > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  async detectFormat(): Promise<ClipboardFormat> {\n    const info = await getClipboardInfo();\n    const formats = parseClipboardFormats(info);\n    if (formats.length > 0) {\n      return formats[0];\n    }\n    throw new Error(\"No image found in clipboard\");\n  }\n\n  async readImage(): Promise<ClipboardImageResult> {\n    const format = await this.detectFormat();\n    const hasNativeClass = format in FORMAT_TO_OSASCRIPT_CLASS;\n    const osClass = hasNativeClass ? FORMAT_TO_OSASCRIPT_CLASS[format] : \"PNGf\";\n    const resolvedFormat = hasNativeClass ? format : \"png\";\n\n    const { stdout } = await execBuffer(\"osascript\", [\n      \"-e\",\n      `set imgData to (the clipboard as \u00ABclass ${osClass}\u00BB)`,\n      \"-e\",\n      \"return imgData\",\n    ]);\n    return { data: stdout, format: resolvedFormat };\n  }\n}\n", "import { ClipboardReader, ClipboardFormat, ClipboardImageResult } from \"./types\";\nimport { PlatformInfo } from \"../platform/detect\";\nimport { exec, execBuffer } from \"../util/exec\";\nimport { resolveToolPathOrFallback } from \"../util/toolPath\";\n\n/** MIME type to ClipboardFormat mapping, in preference order. */\nconst MIME_FORMAT_MAP: Array<[string, ClipboardFormat]> = [\n  [\"image/png\", \"png\"],\n  [\"image/jpeg\", \"jpeg\"],\n  [\"image/webp\", \"webp\"],\n  [\"image/tiff\", \"tiff\"],\n  [\"image/bmp\", \"bmp\"],\n  [\"image/x-bmp\", \"bmp\"],\n];\n\n/** Parse a list of MIME types and return the best matching ClipboardFormat. */\nfunction detectFormatFromMimeTypes(\n  mimeList: string,\n): ClipboardFormat | null {\n  for (const [mime, format] of MIME_FORMAT_MAP) {\n    if (mimeList.includes(mime)) {\n      return format;\n    }\n  }\n  // Check for any unrecognized image/* type\n  if (/^image\\//m.test(mimeList)) {\n    return \"unknown\";\n  }\n  return null;\n}\n\n/** Find the best MIME type and its format from a clipboard type list. */\nfunction detectMimeAndFormat(\n  mimeList: string,\n): { mime: string; format: ClipboardFormat } | null {\n  for (const [mime, format] of MIME_FORMAT_MAP) {\n    if (mimeList.includes(mime)) {\n      return { mime, format };\n    }\n  }\n  if (/^image\\//m.test(mimeList)) {\n    return { mime: \"image/png\", format: \"unknown\" };\n  }\n  return null;\n}\n\nexport class LinuxClipboardReader implements ClipboardReader {\n  private displayServer: PlatformInfo[\"displayServer\"];\n  private resolvedToolPath: string | undefined;\n\n  constructor(displayServer: PlatformInfo[\"displayServer\"]) {\n    this.displayServer = displayServer;\n  }\n\n  private isWayland(): boolean {\n    return this.displayServer === \"wayland\";\n  }\n\n  private toolName(): string {\n    return this.isWayland() ? \"wl-paste\" : \"xclip\";\n  }\n\n  private async getToolPath(): Promise<string> {\n    if (this.resolvedToolPath === undefined) {\n      this.resolvedToolPath = await resolveToolPathOrFallback(this.toolName());\n    }\n    return this.resolvedToolPath;\n  }\n\n  requiredTool(): string {\n    if (this.isWayland()) {\n      return \"wl-clipboard (wl-paste)\";\n    }\n    return \"xclip\";\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    try {\n      if (this.isWayland()) {\n        await exec(\"which\", [\"wl-paste\"]);\n      } else {\n        await exec(\"which\", [\"xclip\"]);\n      }\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /** Get the list of available clipboard types/targets. */\n  private async getClipboardTypes(): Promise<string> {\n    const tool = await this.getToolPath();\n    if (this.isWayland()) {\n      const { stdout } = await exec(tool, [\"--list-types\"]);\n      return stdout;\n    } else {\n      const { stdout } = await exec(tool, [\n        \"-selection\",\n        \"clipboard\",\n        \"-t\",\n        \"TARGETS\",\n        \"-o\",\n      ]);\n      return stdout;\n    }\n  }\n\n  async hasImage(): Promise<boolean> {\n    try {\n      const types = await this.getClipboardTypes();\n      return /^image\\//m.test(types);\n    } catch {\n      return false;\n    }\n  }\n\n  async detectFormat(): Promise<ClipboardFormat> {\n    const types = await this.getClipboardTypes();\n    const format = detectFormatFromMimeTypes(types);\n    if (format !== null) {\n      return format;\n    }\n    throw new Error(\"No image found in clipboard\");\n  }\n\n  async readImage(): Promise<ClipboardImageResult> {\n    const types = await this.getClipboardTypes();\n    const detected = detectMimeAndFormat(types);\n    if (!detected) {\n      throw new Error(\"No image found in clipboard\");\n    }\n    const { mime, format } = detected;\n    const resolvedFormat = format === \"unknown\" ? \"png\" : format;\n\n    const tool = await this.getToolPath();\n    const { stdout } = this.isWayland()\n      ? await execBuffer(tool, [\"--type\", mime])\n      : await execBuffer(tool, [\n          \"-selection\",\n          \"clipboard\",\n          \"-t\",\n          mime,\n          \"-o\",\n        ]);\n    return { data: stdout, format: resolvedFormat };\n  }\n}\n", "import * as fs from \"fs\";\nimport { ClipboardReader, ClipboardFormat, ClipboardImageResult } from \"./types\";\nimport { exec } from \"../util/exec\";\nimport { encodePowerShellCommand } from \"../util/powershell\";\nimport { logger } from \"../util/logger\";\n\nconst PS_HAS_IMAGE =\n  \"Add-Type -AssemblyName System.Windows.Forms; if ([System.Windows.Forms.Clipboard]::ContainsImage()) { echo 'yes' } else { echo 'no' }\";\n\n/** PowerShell script that saves the clipboard image to a temp file and outputs its path. */\nconst PS_READ_IMAGE =\n  \"Add-Type -AssemblyName System.Windows.Forms; $img = [System.Windows.Forms.Clipboard]::GetImage(); if ($img -eq $null) { exit 1 }; $tmp = [System.IO.Path]::GetTempFileName(); $img.Save($tmp, [System.Drawing.Imaging.ImageFormat]::Png); Write-Output $tmp\";\n\n/**\n * Shared base for clipboard readers that use PowerShell to access the\n * Windows clipboard (native Windows and WSL).\n */\nexport abstract class PowerShellClipboardReader implements ClipboardReader {\n  protected abstract get powershellExe(): string;\n\n  abstract requiredTool(): string;\n\n  /** Convert a Windows-style temp path to a path readable by the current OS.\n   *  On native Windows this is an identity operation; on WSL it runs wslpath. */\n  protected abstract resolveTempPath(windowsPath: string): Promise<string>;\n\n  async isToolAvailable(): Promise<boolean> {\n    try {\n      await exec(this.powershellExe, [\"-Command\", \"echo ok\"]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async hasImage(): Promise<boolean> {\n    try {\n      const result = await exec(this.powershellExe, [\n        \"-EncodedCommand\",\n        encodePowerShellCommand(PS_HAS_IMAGE),\n      ]);\n      return result.stdout.trim() === \"yes\";\n    } catch {\n      return false;\n    }\n  }\n\n  async detectFormat(): Promise<ClipboardFormat> {\n    const has = await this.hasImage();\n    if (!has) {\n      throw new Error(\"No image found in clipboard\");\n    }\n    // PowerShell's System.Drawing always re-encodes to PNG\n    return \"png\";\n  }\n\n  async readImage(): Promise<ClipboardImageResult> {\n    const has = await this.hasImage();\n    if (!has) {\n      throw new Error(\"No image found in clipboard\");\n    }\n\n    let tempPath: string;\n    try {\n      const result = await exec(this.powershellExe, [\n        \"-EncodedCommand\",\n        encodePowerShellCommand(PS_READ_IMAGE),\n      ]);\n      tempPath = result.stdout.trim();\n    } catch (err) {\n      throw new Error(\n        `PowerShell execution failed: ${err instanceof Error ? err.message : err}`,\n      );\n    }\n\n    const localPath = await this.resolveTempPath(tempPath);\n    try {\n      const data = await fs.promises.readFile(localPath);\n      return { data, format: \"png\" };\n    } catch (err) {\n      throw new Error(\n        `Temp file read failed: could not read \"${localPath}\": ${err instanceof Error ? err.message : err}`,\n      );\n    } finally {\n      fs.promises.unlink(localPath).catch((err) => {\n        logger.warn(`Failed to clean up temp file: ${localPath}`, err);\n      });\n    }\n  }\n}\n", "/**\n * Encode a PowerShell script as a base64 string suitable for -EncodedCommand.\n * PowerShell expects UTF-16LE encoded base64.\n */\nexport function encodePowerShellCommand(script: string): string {\n  return Buffer.from(script, 'utf16le').toString('base64');\n}\n", "import { PowerShellClipboardReader } from \"./powershellClipboard\";\nimport { resolveToolPathOrFallback } from \"../util/toolPath\";\n\nexport class WindowsClipboardReader extends PowerShellClipboardReader {\n  private resolvedPsPath: string | undefined;\n\n  protected get powershellExe(): string {\n    // Return cached resolved path or fallback to bare name.\n    // Lazy resolution happens in readImage/hasImage via resolvePs().\n    return this.resolvedPsPath ?? \"powershell.exe\";\n  }\n\n  async resolvePs(): Promise<void> {\n    if (this.resolvedPsPath === undefined) {\n      this.resolvedPsPath = await resolveToolPathOrFallback(\"powershell.exe\");\n    }\n  }\n\n  requiredTool(): string {\n    return \"PowerShell (built-in)\";\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    await this.resolvePs();\n    return super.isToolAvailable();\n  }\n\n  protected async resolveTempPath(windowsPath: string): Promise<string> {\n    return windowsPath;\n  }\n}\n", "import { PowerShellClipboardReader } from \"./powershellClipboard\";\nimport { PlatformInfo } from \"../platform/detect\";\nimport { exec } from \"../util/exec\";\n\nexport class WslClipboardReader extends PowerShellClipboardReader {\n  private readonly psPath: string;\n\n  constructor(platform: PlatformInfo) {\n    super();\n    this.psPath = platform.powershellPath ?? \"powershell.exe\";\n  }\n\n  protected get powershellExe(): string {\n    return this.psPath;\n  }\n\n  requiredTool(): string {\n    return \"PowerShell (via WSL interop)\";\n  }\n\n  protected async resolveTempPath(windowsPath: string): Promise<string> {\n    try {\n      const result = await exec(\"wslpath\", [\"-u\", windowsPath]);\n      return result.stdout.trim();\n    } catch (err) {\n      throw new Error(\n        `wslpath conversion failed: could not convert \"${windowsPath}\" to a WSL path: ${err instanceof Error ? err.message : err}`,\n      );\n    }\n  }\n}\n", "import { ClipboardReader, ClipboardFormat, ClipboardImageResult } from \"./types\";\n\n/**\n * Tries each reader in order. The first reader whose operation succeeds wins.\n * If all readers fail, throws an aggregate error with details from each.\n */\nexport class FallbackClipboardReader implements ClipboardReader {\n  private readers: ClipboardReader[];\n\n  constructor(readers: ClipboardReader[]) {\n    if (readers.length === 0) {\n      throw new Error(\"FallbackClipboardReader requires at least one reader\");\n    }\n    this.readers = readers;\n  }\n\n  requiredTool(): string {\n    return this.readers.map((r) => r.requiredTool()).join(\" or \");\n  }\n\n  async isToolAvailable(): Promise<boolean> {\n    for (const reader of this.readers) {\n      if (await reader.isToolAvailable()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  async hasImage(): Promise<boolean> {\n    for (const reader of this.readers) {\n      try {\n        if (await reader.hasImage()) {\n          return true;\n        }\n      } catch {\n        continue;\n      }\n    }\n    return false;\n  }\n\n  async detectFormat(): Promise<ClipboardFormat> {\n    const errors: Error[] = [];\n    for (const reader of this.readers) {\n      try {\n        return await reader.detectFormat();\n      } catch (err) {\n        errors.push(err instanceof Error ? err : new Error(String(err)));\n      }\n    }\n    throw new AggregateError(\n      errors,\n      `All clipboard readers failed to detect format: ${errors.map((e) => e.message).join(\"; \")}`,\n    );\n  }\n\n  async readImage(): Promise<ClipboardImageResult> {\n    const errors: Error[] = [];\n    for (const reader of this.readers) {\n      try {\n        if (!(await reader.isToolAvailable())) {\n          errors.push(\n            new Error(`${reader.requiredTool()}: tool not available`),\n          );\n          continue;\n        }\n        return await reader.readImage();\n      } catch (err) {\n        errors.push(err instanceof Error ? err : new Error(String(err)));\n      }\n    }\n    throw new AggregateError(\n      errors,\n      `All clipboard readers failed: ${errors.map((e) => e.message).join(\"; \")}`,\n    );\n  }\n}\n", "import { PlatformInfo } from \"../platform/detect\";\nimport { ClipboardReader } from \"./types\";\nimport { MacosClipboardReader } from \"./macosClipboard\";\nimport { MacosOsascriptClipboardReader } from \"./macosOsascriptClipboard\";\nimport { LinuxClipboardReader } from \"./linuxClipboard\";\nimport { WindowsClipboardReader } from \"./windowsClipboard\";\nimport { WslClipboardReader } from \"./wslClipboard\";\nimport { FallbackClipboardReader } from \"./fallback\";\n\nexport { ClipboardReader } from \"./types\";\n\nexport function createClipboardReader(platform: PlatformInfo): ClipboardReader {\n  if (platform.isWSL) {\n    const hasDisplayServer =\n      platform.displayServer === \"x11\" || platform.displayServer === \"wayland\";\n\n    // When WSLg is available, prefer native Linux clipboard tools (faster, more\n    // reliable) over PowerShell interop, falling back to PowerShell.\n    // Without WSLg, PowerShell interop is the primary (and possibly only) reader.\n    if (platform.hasWslg && hasDisplayServer) {\n      return new FallbackClipboardReader([\n        new LinuxClipboardReader(platform.displayServer),\n        new WslClipboardReader(platform),\n      ]);\n    }\n\n    const readers: ClipboardReader[] = [new WslClipboardReader(platform)];\n    if (hasDisplayServer) {\n      readers.push(new LinuxClipboardReader(platform.displayServer));\n    }\n\n    return readers.length === 1\n      ? readers[0]\n      : new FallbackClipboardReader(readers);\n  }\n\n  switch (platform.os) {\n    case \"macos\":\n      return new FallbackClipboardReader([\n        new MacosClipboardReader(),\n        new MacosOsascriptClipboardReader(),\n      ]);\n    case \"windows\":\n      return new WindowsClipboardReader();\n    case \"linux\": {\n      const primary = new LinuxClipboardReader(platform.displayServer);\n      const fallbackDS =\n        platform.displayServer === \"wayland\" ? \"x11\" : \"wayland\";\n      const fallback = new LinuxClipboardReader(fallbackDS);\n      return new FallbackClipboardReader([primary, fallback]);\n    }\n  }\n}\n", "import * as crypto from 'crypto';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as vscode from 'vscode';\nimport { logger } from '../util/logger';\nimport { writeSecureFile } from '../util/fs';\nimport type { ClipboardFormat } from '../clipboard/types';\n\nexport interface ImageStore {\n  /** Save an image buffer to the image folder. Returns the absolute file path. */\n  save(imageBuffer: Buffer, format?: ClipboardFormat): Promise<string>;\n\n  /** Delete the oldest images if count exceeds maxImages setting. */\n  cleanup(): Promise<void>;\n\n  /** Ensure the image folder is listed in .gitignore (if autoGitIgnore is enabled). */\n  ensureGitIgnored(): Promise<void>;\n}\n\nconst DEFAULT_FOLDER_NAME = '.tip-images';\n\n/** All image file extensions managed by this store. */\nconst IMAGE_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.tiff', '.bmp', '.webp'];\n\n/** Map from ClipboardFormat to file extension. */\nfunction formatToExtension(format: ClipboardFormat): string {\n  switch (format) {\n    case 'jpeg':\n      return '.jpg';\n    case 'tiff':\n      return '.tiff';\n    case 'bmp':\n      return '.bmp';\n    case 'webp':\n      return '.webp';\n    case 'png':\n    case 'unknown':\n    default:\n      return '.png';\n  }\n}\n\n/** First 8 bytes of every valid PNG file. */\nconst PNG_SIGNATURE = Buffer.from([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n\n/** Validate image data matches the expected format's magic bytes. */\nfunction validateImage(buffer: Buffer, format: ClipboardFormat): void {\n  switch (format) {\n    case 'png':\n      if (buffer.length < PNG_SIGNATURE.length || !buffer.subarray(0, PNG_SIGNATURE.length).equals(PNG_SIGNATURE)) {\n        throw new Error('Clipboard data is not a valid PNG image');\n      }\n      break;\n    case 'jpeg':\n      if (buffer.length < 2 || buffer[0] !== 0xff || buffer[1] !== 0xd8) {\n        throw new Error('Clipboard data is not a valid JPEG image');\n      }\n      break;\n    case 'bmp':\n      if (buffer.length < 2 || buffer[0] !== 0x42 || buffer[1] !== 0x4d) {\n        throw new Error('Clipboard data is not a valid BMP image');\n      }\n      break;\n    case 'webp':\n      if (\n        buffer.length < 12 ||\n        buffer.subarray(0, 4).toString('ascii') !== 'RIFF' ||\n        buffer.subarray(8, 12).toString('ascii') !== 'WEBP'\n      ) {\n        throw new Error('Clipboard data is not a valid WebP image');\n      }\n      break;\n    case 'tiff':\n      if (\n        buffer.length < 2 ||\n        !(\n          (buffer[0] === 0x49 && buffer[1] === 0x49) ||\n          (buffer[0] === 0x4d && buffer[1] === 0x4d)\n        )\n      ) {\n        throw new Error('Clipboard data is not a valid TIFF image');\n      }\n      break;\n    case 'unknown':\n      logger.warn('Skipping image validation for unknown format');\n      break;\n  }\n}\n\nfunction getConfig(): vscode.WorkspaceConfiguration {\n  return vscode.workspace.getConfiguration('terminalImgPaste');\n}\n\nfunction getWorkspaceRoot(): string {\n  const folders = vscode.workspace.workspaceFolders;\n  if (!folders || folders.length === 0) {\n    vscode.window.showErrorMessage(\n      'Terminal Image Paste: No workspace folder is open. Please open a folder first.',\n    );\n    throw new Error('No workspace folder is open');\n  }\n  return folders[0].uri.fsPath;\n}\n\nfunction getFolderName(): string {\n  return getConfig().get<string>('folderName', DEFAULT_FOLDER_NAME);\n}\n\nfunction getImageFolderPath(): string {\n  const root = getWorkspaceRoot();\n  const folderName = getFolderName();\n  const resolved = path.resolve(root, folderName);\n  if (!resolved.startsWith(root + path.sep)) {\n    throw new Error(\n      `Configured folderName \"${folderName}\" must resolve to a subdirectory of the workspace root`,\n    );\n  }\n  return resolved;\n}\n\nconst DEFAULT_FILENAME_PATTERN = 'img-{timestamp}';\n\n/** Placeholders that guarantee unique filenames for rapid consecutive pastes. */\nconst UNIQUENESS_PLACEHOLDERS = ['{timestamp}', '{n}', '{hash}'];\n\n/**\n * Resolve a filename pattern by replacing placeholders with actual values.\n * Exported for unit testing.\n */\nexport function resolveFilenamePattern(\n  pattern: string,\n  imageBuffer: Buffer,\n  existingFiles: string[],\n): string {\n  if (!pattern) {\n    pattern = DEFAULT_FILENAME_PATTERN;\n  }\n\n  const hasPlaceholder = pattern.includes('{');\n  if (!hasPlaceholder) {\n    // No placeholders at all \u2014 append timestamp to avoid collisions\n    const ts = formatTimestamp(new Date());\n    pattern = `${pattern}-${ts}`;\n  } else if (!UNIQUENESS_PLACEHOLDERS.some((p) => pattern.includes(p))) {\n    logger.warn(\n      `Filename pattern \"${pattern}\" lacks a uniqueness placeholder (${UNIQUENESS_PLACEHOLDERS.join(', ')}). Filenames may collide.`,\n    );\n  }\n\n  const now = new Date();\n  let result = pattern;\n\n  // {timestamp}\n  result = result.replace(/\\{timestamp\\}/g, formatTimestamp(now));\n\n  // {date}\n  result = result.replace(/\\{date\\}/g, formatDate(now));\n\n  // {time}\n  result = result.replace(/\\{time\\}/g, formatTime(now));\n\n  // {hash}\n  if (result.includes('{hash}')) {\n    const hash = crypto.createHash('sha256').update(imageBuffer).digest('hex').slice(0, 8);\n    result = result.replace(/\\{hash\\}/g, hash);\n  }\n\n  // {n}\n  if (result.includes('{n}')) {\n    result = resolveSequentialNumber(result, existingFiles);\n  }\n\n  return result;\n}\n\nfunction formatTimestamp(now: Date): string {\n  const y = now.getFullYear();\n  const mo = String(now.getMonth() + 1).padStart(2, '0');\n  const d = String(now.getDate()).padStart(2, '0');\n  const h = String(now.getHours()).padStart(2, '0');\n  const mi = String(now.getMinutes()).padStart(2, '0');\n  const s = String(now.getSeconds()).padStart(2, '0');\n  const ms = String(now.getMilliseconds()).padStart(3, '0');\n  return `${y}-${mo}-${d}T${h}-${mi}-${s}-${ms}`;\n}\n\nfunction formatDate(now: Date): string {\n  const y = now.getFullYear();\n  const mo = String(now.getMonth() + 1).padStart(2, '0');\n  const d = String(now.getDate()).padStart(2, '0');\n  return `${y}-${mo}-${d}`;\n}\n\nfunction formatTime(now: Date): string {\n  const h = String(now.getHours()).padStart(2, '0');\n  const mi = String(now.getMinutes()).padStart(2, '0');\n  const s = String(now.getSeconds()).padStart(2, '0');\n  return `${h}-${mi}-${s}`;\n}\n\n/**\n * Replace `{n}` with the next sequential number.\n * Scans existing files in the folder to determine the highest number used so far.\n */\nfunction resolveSequentialNumber(pattern: string, existingFiles: string[]): string {\n  // Build a regex from the pattern that captures the number where {n} is\n  const escaped = pattern\n    .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n    .replace(/\\\\{n\\\\}/g, '(\\\\d+)');\n  const regex = new RegExp(`^${escaped}`);\n\n  let maxN = 0;\n  for (const file of existingFiles) {\n    // Strip extension for matching\n    const baseName = file.replace(/\\.[^.]+$/, '');\n    const match = baseName.match(regex);\n    if (match && match[1]) {\n      const num = parseInt(match[1], 10);\n      if (num > maxN) {\n        maxN = num;\n      }\n    }\n  }\n\n  return pattern.replace(/\\{n\\}/g, String(maxN + 1));\n}\n\nfunction generateFileName(\n  format: ClipboardFormat,\n  imageBuffer: Buffer,\n  existingFiles: string[],\n): string {\n  const pattern = getConfig().get<string>('filenamePattern', DEFAULT_FILENAME_PATTERN);\n  const baseName = resolveFilenamePattern(pattern, imageBuffer, existingFiles);\n  const ext = formatToExtension(format);\n  return `${baseName}${ext}`;\n}\n\n/**\n * Verify that `target` is inside `root` after resolving symlinks.\n * On case-insensitive filesystems (Windows/macOS) paths are lowercased before\n * comparison; on Linux (case-sensitive) exact casing is preserved.\n * Throws if the resolved path escapes the workspace.\n */\nasync function assertInsideWorkspace(target: string, root: string): Promise<string> {\n  const realTarget = await fs.promises.realpath(target);\n  const realRoot = await fs.promises.realpath(root);\n  // Only normalise case on case-insensitive filesystems (Windows, macOS).\n  // Linux is case-sensitive so lowercasing would bypass the check.\n  const caseInsensitive = process.platform === 'win32' || process.platform === 'darwin';\n  const normTarget = caseInsensitive ? realTarget.toLowerCase() : realTarget;\n  const normRoot = caseInsensitive ? realRoot.toLowerCase() : realRoot;\n  if (normTarget !== normRoot && !normTarget.startsWith(normRoot + path.sep)) {\n    throw new Error(\n      `Image folder resolves to a path outside the workspace (possible symlink escape): ${realTarget}`,\n    );\n  }\n  return realTarget;\n}\n\nexport function createImageStore(): ImageStore {\n  return {\n    async save(imageBuffer: Buffer, format: ClipboardFormat = 'png'): Promise<string> {\n      validateImage(imageBuffer, format);\n\n      const folder = getImageFolderPath();\n      const root = getWorkspaceRoot();\n      await fs.promises.mkdir(folder, { recursive: true });\n\n      // Verify the resolved folder stays within the workspace\n      await assertInsideWorkspace(folder, root);\n\n      let existingFiles: string[];\n      try {\n        existingFiles = await fs.promises.readdir(folder);\n      } catch {\n        existingFiles = [];\n      }\n\n      const fileName = generateFileName(format, imageBuffer, existingFiles);\n      const filePath = path.join(folder, fileName);\n      await writeSecureFile(filePath, imageBuffer);\n\n      // Defense-in-depth: verify the saved file also stays within the workspace\n      await assertInsideWorkspace(filePath, root);\n\n      logger.info(`Saved image: ${filePath}`);\n\n      await this.cleanup();\n      await this.ensureGitIgnored();\n\n      return filePath;\n    },\n\n    async cleanup(): Promise<void> {\n      const config = getConfig();\n      const rawMaxImages = config.get<number>('maxImages', 20);\n      const maxImages =\n        Number.isInteger(rawMaxImages) && rawMaxImages > 0\n          ? rawMaxImages\n          : 20;\n      const folder = getImageFolderPath();\n\n      let entries: string[];\n      try {\n        entries = await fs.promises.readdir(folder);\n      } catch {\n        return;\n      }\n\n      const imageFiles = entries\n        .filter((f) => IMAGE_EXTENSIONS.some((ext) => f.endsWith(ext)))\n        .sort();\n\n      if (imageFiles.length <= maxImages) {\n        return;\n      }\n\n      const toDelete = imageFiles.slice(0, imageFiles.length - maxImages);\n      for (const file of toDelete) {\n        const filePath = path.join(folder, file);\n        try {\n          await fs.promises.unlink(filePath);\n          logger.info(`Deleted old image: ${filePath}`);\n        } catch (err) {\n          logger.warn(`Failed to delete old image: ${filePath}`, err);\n        }\n      }\n    },\n\n    async ensureGitIgnored(): Promise<void> {\n      const config = getConfig();\n      if (!config.get<boolean>('autoGitIgnore', true)) {\n        return;\n      }\n\n      const folderName = getFolderName();\n      const workspaceRoot = getWorkspaceRoot();\n      const gitignorePath = path.join(workspaceRoot, '.gitignore');\n\n      let content: string;\n      try {\n        content = await fs.promises.readFile(gitignorePath, 'utf-8');\n      } catch {\n        await fs.promises.writeFile(gitignorePath, folderName + '\\n', 'utf-8');\n        logger.info(`Created .gitignore with ${folderName}`);\n        return;\n      }\n\n      const lines = content.split('\\n').map((line) => line.trim());\n      if (lines.includes(folderName)) {\n        return;\n      }\n\n      const suffix = content.endsWith('\\n') ? '' : '\\n';\n      await fs.promises.writeFile(\n        gitignorePath,\n        content + suffix + folderName + '\\n',\n        'utf-8',\n      );\n      logger.info(`Added ${folderName} to .gitignore`);\n    },\n  };\n}\n", "import * as fs from 'fs';\n\n/**\n * Write a buffer to disk with restrictive permissions (owner read/write only).\n * All image-writing code should use this to ensure consistent 0o600 permissions.\n */\nexport async function writeSecureFile(filePath: string, data: Buffer): Promise<void> {\n  await fs.promises.writeFile(filePath, data, { mode: 0o600 });\n}\n", "import * as vscode from 'vscode';\nimport { logger } from '../util/logger';\nimport { detectShellType, type ShellType } from './shellDetect';\n\n/**\n * Quote a file path for safe insertion into a specific shell.\n */\nexport function quotePath(filePath: string, shell: ShellType): string {\n  switch (shell) {\n    case 'fish':\n      // Fish uses single quotes but escapes ' with \\'\n      return \"'\" + filePath.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\'\") + \"'\";\n    case 'powershell':\n      // PowerShell uses double quotes; escape ` with ``, $ with `$, \" with `\"\n      return '\"' + filePath.replace(/`/g, '``').replace(/\\$/g, '`$').replace(/\"/g, '`\"') + '\"';\n    case 'cmd':\n      // cmd uses double quotes; escape % with %%, \" with \"\"\n      return '\"' + filePath.replace(/%/g, '%%').replace(/\"/g, '\"\"') + '\"';\n    case 'bash':\n    case 'zsh':\n    case 'unknown':\n    default:\n      // Single-quote the path, escape embedded single quotes with '\\''\n      return \"'\" + filePath.replace(/'/g, \"'\\\\''\") + \"'\";\n  }\n}\n\n/**\n * Send a file path to the active terminal.\n * Detects the shell type and applies the correct quoting strategy.\n * Reads `sendNewline` setting to decide whether to append a newline.\n */\nexport function insertPathToTerminal(filePath: string): void {\n  const terminal = vscode.window.activeTerminal;\n  if (!terminal) {\n    vscode.window.showErrorMessage(\n      'Terminal Image Paste: No active terminal. Please open a terminal first.',\n    );\n    return;\n  }\n\n  const shellType = detectShellType(terminal);\n  const text = quotePath(filePath, shellType);\n\n  const config = vscode.workspace.getConfiguration('terminalImgPaste');\n  const addNewline = config.get<boolean>('sendNewline', false);\n\n  terminal.sendText(text, addNewline);\n  logger.info(`Inserted path into terminal (${shellType}): ${text}`);\n}\n", "import * as vscode from 'vscode';\nimport * as path from 'path';\n\nexport type ShellType = 'bash' | 'zsh' | 'fish' | 'powershell' | 'cmd' | 'unknown';\n\nconst shellPatterns: Array<{ pattern: RegExp; type: ShellType }> = [\n  { pattern: /\\bbash\\b/i, type: 'bash' },\n  { pattern: /\\bzsh\\b/i, type: 'zsh' },\n  { pattern: /\\bfish\\b/i, type: 'fish' },\n  { pattern: /\\b(?:pwsh|powershell)\\b/i, type: 'powershell' },\n  { pattern: /\\bcmd\\b/i, type: 'cmd' },\n];\n\nfunction matchShell(shellPath: string): ShellType {\n  const base = path.basename(shellPath).replace(/\\.exe$/i, '');\n  for (const { pattern, type } of shellPatterns) {\n    if (pattern.test(base)) {\n      return type;\n    }\n  }\n  return 'unknown';\n}\n\nexport function detectShellType(terminal: vscode.Terminal): ShellType {\n  // 1. Check terminal's explicit shell path\n  const shellPath = (terminal.creationOptions as vscode.TerminalOptions)?.shellPath;\n  if (shellPath) {\n    return matchShell(shellPath);\n  }\n\n  // 2. Fall back to SHELL environment variable\n  const envShell = process.env.SHELL;\n  if (envShell) {\n    return matchShell(envShell);\n  }\n\n  // 3. Windows default: PowerShell\n  if (process.platform === 'win32') {\n    return 'powershell';\n  }\n\n  return 'unknown';\n}\n", "import * as fs from 'fs';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { PlatformInfo } from '../platform/detect';\nimport { ClipboardFormat } from '../clipboard/types';\nimport { exec, execBuffer } from '../util/exec';\nimport { writeSecureFile } from '../util/fs';\nimport { encodePowerShellCommand } from '../util/powershell';\nimport { logger } from '../util/logger';\n\nexport type SaveFormat = 'auto' | 'png' | 'jpeg';\n\nexport interface ConversionResult {\n  data: Buffer;\n  format: ClipboardFormat;\n}\n\ntype ConversionTool = 'sips' | 'magick' | 'ffmpeg' | 'powershell';\n\n/**\n * If conversion is needed (saveFormat !== 'auto' and differs from source format),\n * convert using platform-native tools. Returns original data if:\n * - saveFormat is 'auto'\n * - source format already matches target\n * - conversion tool is unavailable (with a warning logged)\n */\nexport async function convertImage(\n  data: Buffer,\n  sourceFormat: ClipboardFormat,\n  targetFormat: SaveFormat,\n  platform: PlatformInfo,\n): Promise<ConversionResult> {\n  if (targetFormat === 'auto' || sourceFormat === targetFormat) {\n    return { data, format: sourceFormat };\n  }\n\n  try {\n    const converted = await convertWithPlatformTool(\n      data,\n      sourceFormat,\n      targetFormat,\n      platform,\n    );\n    return { data: converted, format: targetFormat };\n  } catch (err) {\n    logger.warn(\n      `Image conversion from ${sourceFormat} to ${targetFormat} failed, saving in native format: ${err instanceof Error ? err.message : String(err)}`,\n    );\n    return { data, format: sourceFormat };\n  }\n}\n\nasync function findConversionTool(\n  platform: PlatformInfo,\n): Promise<ConversionTool | null> {\n  if (platform.os === 'macos') {\n    return 'sips';\n  }\n\n  if (platform.os === 'windows' || platform.isWSL) {\n    if (platform.powershellPath) {\n      return 'powershell';\n    }\n    return null;\n  }\n\n  // Linux: try ImageMagick first, then ffmpeg\n  try {\n    await exec('which', ['convert']);\n    return 'magick';\n  } catch {\n    /* not found */\n  }\n  try {\n    await exec('which', ['ffmpeg']);\n    return 'ffmpeg';\n  } catch {\n    /* not found */\n  }\n  return null;\n}\n\nasync function convertWithPlatformTool(\n  data: Buffer,\n  sourceFormat: ClipboardFormat,\n  targetFormat: SaveFormat,\n  platform: PlatformInfo,\n): Promise<Buffer> {\n  const tool = await findConversionTool(platform);\n\n  if (tool === null) {\n    throw new Error('No conversion tool available');\n  }\n\n  switch (tool) {\n    case 'sips':\n      return convertWithSips(data, targetFormat);\n    case 'magick':\n      return convertWithMagick(data, sourceFormat, targetFormat);\n    case 'ffmpeg':\n      return convertWithFfmpeg(data, targetFormat);\n    case 'powershell':\n      return convertWithPowershell(data, targetFormat, platform.powershellPath!);\n  }\n}\n\nasync function convertWithSips(\n  data: Buffer,\n  targetFormat: SaveFormat,\n): Promise<Buffer> {\n  const tmpDir = os.tmpdir();\n  const inputPath = path.join(tmpDir, `tip-convert-in-${Date.now()}`);\n  const targetExt = targetFormat === 'jpeg' ? 'jpg' : 'png';\n  const outputPath = path.join(tmpDir, `tip-convert-out-${Date.now()}.${targetExt}`);\n\n  await writeSecureFile(inputPath, data);\n  try {\n    const sipsFormat = targetFormat === 'jpeg' ? 'jpeg' : 'png';\n    await exec('sips', [\n      '--setProperty',\n      'format',\n      sipsFormat,\n      inputPath,\n      '--out',\n      outputPath,\n    ]);\n    return await fs.promises.readFile(outputPath);\n  } finally {\n    await fs.promises.unlink(inputPath).catch(() => {});\n    await fs.promises.unlink(outputPath).catch(() => {});\n  }\n}\n\nasync function convertWithMagick(\n  data: Buffer,\n  sourceFormat: ClipboardFormat,\n  targetFormat: SaveFormat,\n): Promise<Buffer> {\n  const inputSpec = `${sourceFormat}:-`;\n  const outputSpec = `${targetFormat}:-`;\n  const result = await execBuffer('convert', [inputSpec, outputSpec], {\n    input: data,\n  });\n  return result.stdout;\n}\n\nasync function convertWithFfmpeg(\n  data: Buffer,\n  targetFormat: SaveFormat,\n): Promise<Buffer> {\n  const codec = targetFormat === 'png' ? 'png' : 'mjpeg';\n  const result = await execBuffer(\n    'ffmpeg',\n    [\n      '-hide_banner',\n      '-loglevel',\n      'error',\n      '-f',\n      'image2pipe',\n      '-i',\n      '-',\n      '-f',\n      'image2',\n      '-c:v',\n      codec,\n      '-',\n    ],\n    { input: data },\n  );\n  return result.stdout;\n}\n\nasync function convertWithPowershell(\n  data: Buffer,\n  targetFormat: SaveFormat,\n  powershellPath: string,\n): Promise<Buffer> {\n  const formatEnum = targetFormat === 'png' ? 'Png' : 'Jpeg';\n  const script = `\nAdd-Type -AssemblyName System.Drawing\n$stdin = [Console]::OpenStandardInput()\n$ms = New-Object System.IO.MemoryStream\n$stdin.CopyTo($ms)\n$ms.Position = 0\n$img = [System.Drawing.Image]::FromStream($ms)\n$outMs = New-Object System.IO.MemoryStream\n$img.Save($outMs, [System.Drawing.Imaging.ImageFormat]::${formatEnum})\n[Console]::OpenStandardOutput().Write($outMs.ToArray(), 0, $outMs.Length)\n$img.Dispose()\n$ms.Dispose()\n$outMs.Dispose()\n`;\n  const result = await execBuffer(\n    powershellPath,\n    ['-NoProfile', '-EncodedCommand', encodePowerShellCommand(script)],\n    { input: data },\n  );\n  return result.stdout;\n}\n", "/**\n * Simple async mutex for serializing operations.\n * Usage:\n *   const release = await mutex.acquire();\n *   try { ... } finally { release(); }\n */\nexport class Mutex {\n  private _queue: Array<() => void> = [];\n  private _locked = false;\n\n  acquire(): Promise<() => void> {\n    return new Promise<() => void>((resolve) => {\n      const tryAcquire = () => {\n        if (!this._locked) {\n          this._locked = true;\n          resolve(() => {\n            this._locked = false;\n            const next = this._queue.shift();\n            if (next) {\n              next();\n            }\n          });\n        } else {\n          this._queue.push(tryAcquire);\n        }\n      };\n      tryAcquire();\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["extension_exports", "__export", "activate", "deactivate", "__toCommonJS", "vscode", "fs", "import_child_process", "cached", "detectOS", "readProcVersion", "detectWSL", "procVersion", "detectWslVersion", "detectWslg", "detectDisplayServer", "os", "isWSL", "sessionType", "whichSync", "name", "detectPowershellPath", "candidates", "candidate", "fromPath", "detectPlatform", "wslVersion", "hasWslg", "displayServer", "powershellPath", "vscode", "detectRemoteContext", "remoteName", "import_child_process", "DEFAULT_TIMEOUT", "DEFAULT_MAX_BUFFER", "DEFAULT_MAX_BUFFER_BINARY", "exitCode", "error", "exec", "command", "args", "options", "resolve", "reject", "stdout", "stderr", "execBuffer", "execBufferWithStdin", "stderrStr", "timeout", "maxBuffer", "child", "stdoutChunks", "stderrChunks", "stdoutLen", "stderrLen", "finished", "timer", "chunk", "err", "code", "import_child_process", "vscode", "timestamp", "now", "h", "m", "s", "ms", "createLogger", "name", "channel", "message", "err", "line", "logger", "cache", "isWindows", "resolveToolPath", "toolName", "cached", "resolver", "resolved", "resolve", "reject", "error", "stdout", "firstLine", "logger", "resolveToolPathOrFallback", "getClipboardInfo", "stdout", "exec", "parseClipboardFormats", "info", "formats", "MacosClipboardReader", "resolveToolPathOrFallback", "pngpaste", "execBuffer", "FORMAT_TO_OSASCRIPT_CLASS", "MacosOsascriptClipboardReader", "info", "getClipboardInfo", "parseClipboardFormats", "formats", "format", "hasNativeClass", "osClass", "resolvedFormat", "stdout", "execBuffer", "MIME_FORMAT_MAP", "detectFormatFromMimeTypes", "mimeList", "mime", "format", "detectMimeAndFormat", "LinuxClipboardReader", "displayServer", "resolveToolPathOrFallback", "exec", "tool", "stdout", "types", "detected", "resolvedFormat", "execBuffer", "fs", "encodePowerShellCommand", "script", "PS_HAS_IMAGE", "PS_READ_IMAGE", "PowerShellClipboardReader", "exec", "encodePowerShellCommand", "tempPath", "err", "localPath", "logger", "WindowsClipboardReader", "PowerShellClipboardReader", "resolveToolPathOrFallback", "windowsPath", "WslClipboardReader", "PowerShellClipboardReader", "platform", "windowsPath", "exec", "err", "FallbackClipboardReader", "readers", "r", "reader", "errors", "err", "e", "createClipboardReader", "platform", "hasDisplayServer", "FallbackClipboardReader", "LinuxClipboardReader", "WslClipboardReader", "readers", "MacosClipboardReader", "MacosOsascriptClipboardReader", "WindowsClipboardReader", "primary", "fallbackDS", "fallback", "crypto", "fs", "path", "vscode", "fs", "writeSecureFile", "filePath", "data", "DEFAULT_FOLDER_NAME", "IMAGE_EXTENSIONS", "formatToExtension", "format", "PNG_SIGNATURE", "validateImage", "buffer", "logger", "getConfig", "getWorkspaceRoot", "folders", "getFolderName", "getImageFolderPath", "root", "folderName", "resolved", "DEFAULT_FILENAME_PATTERN", "UNIQUENESS_PLACEHOLDERS", "resolveFilenamePattern", "pattern", "imageBuffer", "existingFiles", "p", "ts", "formatTimestamp", "now", "result", "formatDate", "formatTime", "hash", "resolveSequentialNumber", "y", "mo", "d", "h", "mi", "ms", "s", "escaped", "regex", "maxN", "file", "match", "num", "generateFileName", "baseName", "ext", "assertInsideWorkspace", "target", "realTarget", "realRoot", "caseInsensitive", "normTarget", "normRoot", "createImageStore", "folder", "fileName", "filePath", "writeSecureFile", "rawMaxImages", "maxImages", "entries", "imageFiles", "f", "toDelete", "err", "workspaceRoot", "gitignorePath", "content", "line", "suffix", "vscode", "path", "shellPatterns", "matchShell", "shellPath", "base", "pattern", "type", "detectShellType", "terminal", "envShell", "quotePath", "filePath", "shell", "insertPathToTerminal", "terminal", "shellType", "detectShellType", "text", "addNewline", "logger", "fs", "os", "path", "convertImage", "data", "sourceFormat", "targetFormat", "platform", "convertWithPlatformTool", "err", "logger", "findConversionTool", "exec", "tool", "convertWithSips", "convertWithMagick", "convertWithFfmpeg", "convertWithPowershell", "tmpDir", "inputPath", "targetExt", "outputPath", "writeSecureFile", "inputSpec", "outputSpec", "execBuffer", "powershellPath", "encodePowerShellCommand", "Mutex", "resolve", "tryAcquire", "next", "handleCommandError", "commandName", "err", "message", "logger", "activate", "context", "platform", "detectPlatform", "reader", "createClipboardReader", "imageStore", "createImageStore", "available", "pasteMutex", "Mutex", "pasteImageDisposable", "release", "config", "remoteCtx", "detectRemoteContext", "data", "format", "saveFormat", "converted", "convertImage", "filePath", "insertPathToTerminal", "sendPathDisposable", "uri", "deactivate"]
}
